<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>408|操作系统笔记：第一章 操作系统概述 | Twojian Blog</title>
<meta name="keywords" content="操作系统, ">
<meta name="description" content="操作系统核心概念和发展">
<meta name="author" content="Twojian">
<link rel="canonical" href="https://twojian.github.io/posts/blog/%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/">
<meta name="google-site-verification" content="XYZabc">
<meta name="yandex-verification" content="XYZabc">
<meta name="msvalidate.01" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css" integrity="sha256-NDzEgLn/yPBMy&#43;XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://twojian.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://twojian.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://twojian.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://twojian.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://twojian.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://twojian.github.io/posts/blog/%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
  onload="renderMathInElement(document.body, {
    delimiters: [
      {left: '$$', right: '$$', display: true},
      {left: '$', right: '$', display: false}
    ],
    throwOnError: false
  });">
</script>

<meta property="og:url" content="https://twojian.github.io/posts/blog/%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/">
  <meta property="og:site_name" content="Twojian Blog">
  <meta property="og:title" content="408|操作系统笔记：第一章 操作系统概述">
  <meta property="og:description" content="操作系统核心概念和发展">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-12-30T12:00:00+08:00">
    <meta property="article:modified_time" content="2025-12-30T12:00:00+08:00">
    <meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="408|操作系统笔记：第一章 操作系统概述">
<meta name="twitter:description" content="操作系统核心概念和发展">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://twojian.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "408|操作系统笔记：第一章 操作系统概述",
      "item": "https://twojian.github.io/posts/blog/%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "408|操作系统笔记：第一章 操作系统概述",
  "name": "408|操作系统笔记：第一章 操作系统概述",
  "description": "操作系统核心概念和发展",
  "keywords": [
    "操作系统", ""
  ],
  "articleBody": "第一章操作系统概述 第一章 操作系统概述 【考频统计】\n年份 考点 分值 2009 并发与并行（批处理系统） 2分 2010 系统调用 2分 2011 操作系统运行机制（用户态、内核态） 2分 2012 操作系统运行机制（用户态、内核态） 2分 2013 操作系统运行机制（用户态、内核态）、操作系统引导、系统调用 23 = 6分 2014 操作系统运行机制（用户态、内核态） 2分 2015 操作系统运行机制（用户态、内核态） 2分 2016 批处理系统 2分 2017 系统调用、批处理系统 22=4分 2018 批处理系统 2分 2019 系统调用 2分 2020 2021 操作系统运行机制（用户态、内核态）、系统调用 22=4分 2022 批处理系统、操作系统引导(初始化)、操作系统运行机制（用户态、内核态）、系统调用 42=8分 2023 宏内核与微内核、操作系统运行机制（用户态、内核态） 22=4分 【考点分析】：注意到用户态与内核态这个知识点考察了8次、系统调用考察了6次、批处理系统（多道程序设计）考察了5次，这几个知识点必须弄得十分清楚！！！此外，异常与中断这个知识点也超级重要，另见单独章节！！！\n【系统调用的完整过程必须要弄清楚】：大题隐藏考点\n1.1 操作系统的基本概念 1.1.1 操作系统的概念 操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源(是系统资源的管理者)，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境(向上层提供方便易用的服务)；它是计算机系统中最基本的系统软件（最接近硬件的一层软件）。\n1.1.2 操作系统的特征 1. 并发(Concurrence)\n指两个或多个事件在同一时间间隔内发生(引入进程的目的就是使程序可以并发执行) 这些事件宏观上是同时发生的，但微观上是交替发生的(通过分时实现) 常考易混概念——并行：指两个或多个事件在同一时刻同时发生。\n操作系统就是伴随着\"多道程序技术\"而出现的。因此，操作系统和程序并发是一起诞生的。\n【注】：并行性是指系统具有同时进行运算或操作的特性，在同一时刻能完成多种工作。并行性需要有相关硬件的支持，如多流水线或多处理机硬件环境。\n2. 共享(Sharing)\n即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。\n共享方式：\n互斥共享方式：系统中的某些资源，虽然可以提供多个进程使用，但一个时间段内只允许一个进程访问该资源。 适用于打印机、磁带机等大多数物理设备，某些软件中使用的栈、变量和表格等临界资源\n同时共享(访问)方式：系统中的某些资源，允许一个时间段内由多个进程\"同时\"对它们进行访问，所谓的\"同时\"往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享） 适用于磁盘设备、用重入码编写的文件等资源\n**如何判断是互斥还是同时访问：**如果若干进行交替使用设备对结果没有影响，则需同时访问方式(如磁盘)，如果会产生影响，则要互斥访问(如打印机等)；\n生活实例：\n互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。 同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的 并发性指计算机系统中同时存在着多个运行着的程序。共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。 并发和共享的关系：二者是操作系统最基本的特征，互为存在的条件： ①资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题； ②若系统不能对资源贡献实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。\n3. 虚拟(Virtual)\n虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。\n虚拟处理器：通过多道程序设计技术，让其并发执行来分时使用一个处理器；(时分复用技术，微观上处理机在各个微小的时间段内交替着为各个进程服务) 虚拟存储器：利用覆盖、交换、请求分页/分段/段页等技术逻辑上扩充存储器的容量；(空分复用技术) 虚拟设备：SPOOLing技术将一台物理I/O设备虚拟为多台逻辑上的I/O设备。\n显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性\n4. 异步(Asynchronism)\n在多道程序环境下，允许多个程序并发执行，由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。\n如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。\n1.1.3 操作系统的功能和目标 作为系统资源的管理者(对应着后面四章)\n处理机管理：即分配和控制处理机，主要包括了进程控制、进程同步、进程通信、调度等 存储器管理：主要有内存分配、内存保护、地址映射、虚拟存储等 设备管理：包括缓冲管理、设备分配、设备驱动等 文件管理：包括文件存储空间的管理、目录管理、文件的读/写管理和保护等 作为用户与计算机硬件系统之间的接口\n封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。\n命令接口：用户利用这些操作命令来组织和控制作业的执行； 联机命令接口：即交互式命令接口，适用于分时或实时系统 ；说一句干一句；\n脱机命令接口：批处理命令接口，适用于批处理系统，由一组控制命令组成 ；提供一个事情清单，一条一条完成；\n程序接口：由一组系统调用(也称广义指令)组成。用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，如使用各种外部设备、申请分配和回收内存及其他要求；例如图形用户接口GUI。 实现对计算机资源的抽象(扩充)：\n💡 没有任何软件支持的计算机称为裸机，它仅构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。裸机在最里层，其外面是操作系统。操作系统所提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器：因此，我们通常把覆盖了软件的机器称为扩充机器或虚拟机。\n1.2 操作系统发展历程 1.2.1 手工操作阶段 缺点：用户独占全机，资源利用率极低；CPU等待手工操作，利用不充分\n1.2.2 批处理阶段 引入脱机输入/输出技术（用外围机+磁带完成），并由监督程序负责控制作业的输入、输出\n单道批处理系统：系统对作业的处理是成批进行的，但内存中**始终保持一道作业；**是在解决人机矛盾及CPU和I/O设备速率不匹配的矛盾中形成的；\n特点： 自动性：磁带上的一批作业自动逐个运行，而无须人工干预，缓解了一定程度的人机速度矛盾，资源利用率有所提升。 顺序性：各道作业顺序进入内存，顺序完成； 单道性：内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I/O完成，资源利用率依然很低。 多道批处理系统：每次往内存中读入多道程序，作业成批运行\n主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持\"忙碌\"状态，系统吞吐量增大 主要缺点：用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。eg：无法调试程序/无法在程序运行过程中输入一些参数） 多道程序设计技术（多任务又名多道程序）：允许多个程序同时进入内存并允许它们在CPU中交替地运行，这些程序共享系统中的各种硬/软件资源。当一道程序因I/O请求而暂停运行时，借助中断技术CPU便立即转去运行另一道程序。它不采用某些机制来提高某一技术方面的瓶颈问题，而让系统的各个组成部分都尽量去\"忙\"，因此切换任务所花费的时间很少，可实现系统各部件之间的并行工作，使其整体在单位时间内的效率翻倍。当然，多道批处理系统的设计和实现要比单道系统复杂很多，因为要充分利用各种资源，就要涉及各种资源的调度问题。多道程序设计的特点：\n多道，计算机内存中同时存放多道相互独立的程序。 宏观上并行，同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行，但都未运行完毕 微观上串行，内存中的多道程序轮流占有CPU，交替执行。 多道程序设计技术的实现需要解决下列问题：\n如何分配处理器。 多道程序的内存分配问题。 I/O设备如何分配。 如何组织和存放大量的程序和数据，以方便用户使用并保证其安全性与一致性。 1.2.3 分时操作系统 计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。\n主要优点：用户请求可以被及时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。 主要缺点：不能优先处理一些紧急任务(不能在比时间片还短的时间内快速做出反应)，操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。 1.2.4 实时操作系统 主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。\n在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性\n硬实时系统：必须保证让某个特定的动作在规定的时间内完成；如导弹制导、自动驾驶等 软实时系统：若能够接受偶尔违反时间规定且不会引起任何永久性的损害； 如12315订票系统、银行管理系统等 1.2.5 网络操作系统和分布式计算机系统 网络操作系统是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用) 分布式操作系统：主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。 1.2.6 个人操作系统 个人计算机操作系统是目前使用最广泛的操作系统，它广泛应用于文字处理、电子表格、游戏中，常见的有 Windows、Linux和MacOS等。\ntimeline title 操作系统发展简表 手工阶段 : 独占资源，利用率低 脱机处理 : 外围机+磁带，减小CPU空闲 早期批处理 : 提升CPU利用 多道批处理 : 宏观并行、微观串行 分时操作系统 : 时间片轮转，交互强 实时操作系统 : 及时性、可靠性 网络操作系统 : 资源共享与通信 分布式操作系统 : 建立在网络OS上，控制分布化 个人计算机 : 普及最广 资源利用率：批处理 \u003e 分时 \u003e 实时 交互性： 分时 \u003e 实时 \u003e 批处理 及时性：实时 \u003e 分时 \u003e 批处理 可靠性：实时(最强) 分时：实现了人机交互的功能 批处理：实现了作业自动运行控制的功能\n1.2.7 该考点真题 【2009-23】单处理机系统中，可并行的是（ ）。\nⅠ. 进程与进程\nⅡ. 处理机与设备\nⅢ. 处理机与通道\nⅣ. 设备与设备\nA. Ⅰ、Ⅱ和Ⅲ\nB. Ⅰ、Ⅱ和Ⅳ\nC. Ⅰ、Ⅲ和Ⅳ\nD. Ⅱ、Ⅲ和Ⅳ\n答案\n单处理机系统（不包含多核的情况）中，同一时刻只能有一个进程占用处理机，因此进程之间不能并行执行，只能串行执行。I错误。\n设备独立于处理机，两者可以并行。II正确。\n通道是独立于处理机的控制输入/输出的设备，两者可以并行。III正确。\n设备与设备之间相互独立，可以并行。IV正确。\n综上，Ⅱ、Ⅲ和Ⅳ正确。\n本题选D。\n【2016-23】下列关于批处理系统的叙述中，正确的是（ ）。\nⅠ.批处理系统允许多个用户与计算机直接交互\nⅡ.批处理系统分为单道批处理系统和多道批处理系统\nⅢ.中断技术使得多道批处理系统的I/O设备可与CPU并行工作\nA. 仅Ⅱ、Ⅲ\nB. 仅Ⅱ\nC.仅Ⅰ、Ⅱ\nD. 仅Ⅰ、Ⅲ\n答案\nI错误。批处理系统是一种处理方式，其中用户将一批作业提交给计算机系统，而不是直接与计算机进行交互。在批处理系统中，作业按照预定的顺序依次执行，而不需要用户的干预。\nII正确。批处理系统分为单道批处理系统和多道批处理系统。单道批处理系统是最早的批处理系统，它一次只能执行一个作业。多道批处理系统则允许多个作业同时加载到内存中，可以并行执行，提高了系统的资源利用率。\nIII正确。中断是一种计算机系统中的事件通知机制，可以打断CPU正在执行的程序，并转而处理其他任务。在多道批处理系统中，当一个作业的I/O操作开始时，CPU可以切换到另一个作业进行处理，从而实现I/O设备和CPU的并行工作，提高了系统的吞吐量。\n综上，仅Ⅱ、Ⅲ正确。本题选A。\n【2017-28】与单道程序系统相比，多道程序系统的优点是（ ）。\nⅠ. CPU利用率高\nⅡ. 系统开销小\nⅢ. 系统吞吐量大\nⅣ. I/O设备利用率高\nA. 仅Ⅰ、Ⅲ\nB. 仅Ⅰ、Ⅳ\nC. 仅Ⅱ、Ⅲ\nD. 仅Ⅰ、Ⅲ、Ⅳ\n答案\nⅠ正确。多道程序系统能够同时运行多个程序，通过进程切换和时间片轮转等调度算法，实现了多个程序的并发执行。这样可以充分利用CPU资源，提高CPU的利用率。\nⅡ错误。多道程序系统要付出额外的开销来组织作业和切换作业。\nⅢ正确。多道程序系统能够同时处理多个程序，从而提高了系统的吞吐量。\nⅣ正确。多道程序系统能够同时处理多个程序的I/O请求。当一个程序在等待一个I/O操作完成时，系统可以切换到另一个程序，继续执行其他任务，从而提高了I/O设备的利用率。\n综上，仅Ⅰ、Ⅲ、Ⅳ正确。\n本题选D。\n【2018-23】下列关于多任务操作系统的叙述中，正确的是（ ）。\nⅠ. 具有并发和并行的特点\nⅡ. 需要实现对共享资源的保护\nⅢ. 需要运行在多CPU的硬件平台上\nA. 仅Ⅰ\nB. 仅Ⅱ\nC. 仅Ⅰ、Ⅱ\nD. Ⅰ、Ⅱ、Ⅲ\n答案\nI正确。多任务操作系统具有并发和并行的特点，可以同时执行多个任务或进程，并能够充分利用多核CPU或多个CPU进行并行处理。\nII正确。由于多个任务或进程可能会竞争使用共享资源（如内存、硬盘等），因此需要实现对共享资源的保护。\nIII错误。需要运行在多CPU的硬件平台上并不是必要条件，多任务操作系统可以在单CPU的硬件平台上运行，只是在多CPU的硬件平台上可以更好地发挥并行处理的能力。现代操作系统（如：Windows、Linux、Mac OS X等）允许同时运行多个进程，分时操作系统分配给每个正在运行的进程微观上的一段CPU时间，称为时间片，在只考虑一个CPU的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短，用户不会感觉到。\n综上，仅Ⅰ、Ⅱ正确。\n本题选C。\n【2022-23】下列关于多道程序系统的叙述中，不正确的是（ ）。\nA. 支持进程的并发执行\nB. 不必支持虚拟存储管理\nC. 需要实现对共享资源的管理\nD. 进程数越多CPU利用率越高\n答案\nA正确。多道程序系统可以同时（宏观上）运行多个进程，使它们在系统中并发执行。\nB正确。在计算机的早期，多道程序系统中CPU一次读取多个程序放入内存，不必支持虚拟存储管理。\nC正确。在多道程序系统中，多个进程可能同时访问和使用共享资源，如内存、文件系统、设备等。为了避免冲突和资源竞争，操作系统需要实现对共享资源的管理，例如使用锁机制或信号量等机制来协调进程对共享资源的访问。\nD不正确。进程数越多，由于竞争CPU的资源，实际上可能降低CPU利用率。\n本题选D。\n1.3 操作系统运行环境 CPU的特权级\n特权级是CPU的硬件特征，分为用户态和内核态，用户程序运行在用户态，操作系统运行在内核态； 代码和数据也具备特权级，只有CPU此时的特权级高于想要访问的代码或数据的特权级时才能访问。 内核空间：操作系统程序和数据占用的内存空间，只有内核态下才可以访问；\n用户空间：用户代码所占用的内存空间，用户态下可以访问；\n当CPU想要访问内存时，会进行特权级检查，只有当CPU特权级高于被访问数据的特权级时才能访问。\n1.3.1 操作系统运行机制 应用程序运行在用户态（目态）下，只能执行非特权指令。\n内核程序运行在内核态（管态）下，是操作系统最重要最核心的部分，也是最接近硬件的部分。\n内核是计算机配置的底层软件，它管理着系统的各种资源，大多数内核包含着以下四方面内容：\n时钟管理：提供系统时间、进程切换、时间片、分时操作、作业运行程度衡量、时钟中断等等（读时钟不算） 中断机制：负责保护和恢复中断现场的信息，转移控制权到相关的处理程序 原语：操作系统最底层，最接近硬件；原子性：只能一次性完成，不可中断（通过关闭中断实现）；运行时间短，调用频繁 系统控制的数据结构及处理：例如：作业控制块、进程控制块 PCB、文件控制块、设备控制块、各链表、消息队列、缓冲区、内存分配表等等的一些基本操作 补充：内核数据结构\n操作系统的内核是其最核心的部分，负责管理系统资源和简化硬件与应用程序之间的交互。内核的数据结构对于其性能和功能至关重要，不同的操作系统可能有不同的实现方式和优化策略。以下是一些常见的内核数据结构：\n进程控制块（PCB，Process Control Block）： 这是最关键的数据结构之一，用于存储关于系统中每个进程的信息。它包括进程状态、进程编号（PID）、程序计数器、寄存器集的状态、内存管理信息（如页表）、账户信息、I/O状态信息（如分配给进程的文件描述符）、以及执行统计。 文件描述符表： 用于管理打开文件的引用。每个进程通常都有一个文件描述符表，表中的每个条目指向一个文件表，其中包含文件的位置、读写位置和访问权限。 内存管理结构： 页表：映射虚拟地址到物理地址的数据结构。 段表：在基于段的内存管理中使用，用来映射线性地址空间到物理内存。 伙伴系统（Buddy System）：用于内存分配的数据结构，支持动态内存分配与释放。 空闲内存列表或位图：跟踪可用物理内存的数据结构。 调度队列： 管理就绪进程的队列，通常包括多个不同优先级的队列。 等待队列：用于等待特定资源或事件的进程列表。 中断向量表： 一个数组，存储中断服务例程（ISR）的地址。当发生中断时，CPU会使用这个表来确定应当调用哪个服务例程。 同步原语的数据结构： 信号量、互斥锁（Mutex）和条件变量等，用于进程或线程间的同步。 设备驱动表： 包含系统中所有设备的驱动程序的指针和状态信息。 缓冲区和缓存管理： 用于文件系统和I/O系统，比如缓冲区高速缓存和页缓存。 【注】：\n用户态不能执行特权指令（只有内核程序才能执行），内核态除了访管指令外，可执行一切指令； **必须在内核态的操作指令：**与I/O、置时钟、置中断、内存保护寄存器、程序状态寄存器等相关的指令 CPU 中有一个寄存器叫程序状态字寄存器（PSW），其中有个二进制位，1表示\"内核态\"，0表示\"用户态\" 常见的事件如系统调用、外部中断和缺页等都是发生在用户态的，进程切换和缺页处理等只能发生在内核态；常见的指令如陷阱指令、跳转指令、数据传送指令和设置断点指令等都在用户态执行，所有特权指令如关中断指令、I/O 指令等只能在内核态执行。 多重中断机制下的寄存器保存：在多重中断环境中，由于中断可能在用户态或内核态下响应，因此PSW寄存器必须保存（其中的特权标志位指示当前响应中断的进程状态）。而普通子程序或函数调用不涉及特权级切换，全程在用户态执行，故无需保存PSW。\n用户栈与内核栈\n用户栈（低特权级）：支持用户空间程序执行\n管理函数调用的局部变量、参数和返回地址 处理用户程序中的函数调用和返回逻辑 仅限用户态访问，无法直接操作内核资源 内核栈（高特权级）：支持内核代码执行\n当进程通过系统调用、中断或异常进入内核态时，硬件自动切换到内核栈 存储内核函数调用链、临时变量及执行上下文 确保内核代码安全执行，防止用户态数据污染内核空间 进程独立内核栈的必要性\n所有进程在运行时都可能通过系统调用陷入内核态继续执行。假设进程A陷入内核执行时需等待资源，主动调用schedule()让出CPU，而进程B随后也通过系统调用进入内核态，若共享内核栈，则进程B的系统调用压栈操作将破坏进程A的栈数据，导致系统不稳定。\n该考点真题 【2011-24】下列选项中，在用户态执行的是（ ）。\nA. 命令解释程序\nC. 进程调度程序\nB. 缺页处理程序\nD. 时钟中断处理程序\n答案\nA正确。命令解释程序 (Command Interpreter) 是运行在用户态的应用程序，也称为shell。它接收用户输入的命令，并将其解释和执行。命令解释程序负责解析命令行参数、调用相应的系统调用和应用程序来执行命令，以及显示结果给用户。\nB、C、D错误。进程调度程序、缺页处理程序和时钟中断处理程序通常是在内核态（也称为特权态）下执行的。这些程序涉及到底层的操作系统功能，需要更高的权限才能执行。\n本题选A。\n【2012-23】下列选项中，不可能在用户态发生的事件是（ ）。\nA. 系统调用\nB. 外部中断\nC. 进程切换\nD. 缺页\n答案\n本题考察“在用户态发生”，而非“在用户态执行”。\nA错误。系统调用是由用户态程序主动发起的请求，用于请求操作系统提供特权操作或资源访问权限.\nB错误。外部中断是由外部设备或事件触发的中断请求，可能发生在用户态。外部中断通常在内核态进行处理。\nC正确。进程切换是操作系统调度器根据调度策略从一个运行的进程切换到另一个进程的操作。用户态程序是无法直接调用进程切换的，程序只能通过系统调用接口向操作系统发送某些请求，如fork、exec、yield等，然后由操作系统内核在内核态中处理这些请求，处理请求的过程中可能需要进行进程切换。进程切换涉及到修改和管理进程的上下文信息，包括保存和恢复寄存器状态、切换页表等操作。\nD错误。缺页指的是程序访问的内存页不在物理内存中，需要通过页表映射和磁盘交换等机制从磁盘加载到内存中才能继续执行。当用户态程序访问一个缺页时，处理器会触发缺页异常，并由操作系统在内核态进行缺页处理。\n本题选C。\n【2013-28】下列选项中，会导致用户进程从用户态切换到内核态的操作是（ ）。\nI. 整数除以零\nsin() 函数调用 read 系统调用 A. 仅 I、II\nB. 仅 I、III\nC. 仅 II、III\nD. I、II 和 III\n答案\nI正确。整数除以零导致异常。该异常会导致处理器从用户态切换到内核态，以便内核能够处理异常情况。\nII错误。调用数学库函数如 sin() 不会导致用户进程切换到内核态。这样的函数调用仅在用户态执行，然后返回结果给用户进程。\nIII正确。read 系统调用用于从文件描述符读取数据。当用户进程调用 read 系统调用时，它必须切换到内核态，以便内核可以执行读取文件的操作。这涉及到访问和操作内核数据结构，因此用户进程会从用户态切换到内核态。\n综上，I和III正确。\n本题选B。\n【2014-25】下列指令中，不能在用户态执行的是（ ）。\nA. trap指令\nB. 跳转指令\nC. 压栈指令\nD. 关中断指令\n答案\n在用户态执行的指令是受限制的，通常只能执行非特权操作。\nA错误。trap指令即陷阱指令，用户在发起系统调用时，在执行完传送指令将参数传送至寄存器后，便会执行trap指令陷入内核态。\nB错误。跳转指令用于在程序中无条件或有条件地跳转到指定的地址。跳转指令通常是用户态程序的一部分，因此可以在用户态执行。\nC错误。压栈指令是将数据压入栈中的指令，用于保存当前执行环境和数据。在用户态程序中，可以使用压栈指令来维护局部变量、函数调用的返回地址等，因此可以在用户态执行。\nD正确。关中断指令用于在处理器中禁用中断请求。这个指令是一种特权操作，只有处于内核态（特权态）的代码才能执行。用户态程序没有权限执行关中断指令。\n本题选D。\n【2015-24】假定下列指令已装入指令寄存器，则执行时不可能导致CPU从用户态变为内核态（系统态）的是（ ）。\nA. DIV R0, R1 ；(R0) / (R1) → R0\nB. INT n ；产生软中断\nC. NOT R0 ；寄存器R0的内容取非\nD. MOV R0, addr ；把地址addr处的内存数据放入寄存器R0中\n答案\nA错误。指令 DIV R0, R1 执行的是除法操作，若除数(R1)为0，则产生异常，需要操作系统在内核态进行处理，会导致CPU从用户态变为内核态。\nB错误。指令 INT n 产生软中断，会触发相应的的中断处理程序，需要操作系统在内核态进行处理，会导致CPU从用户态变为内核态。\nC正确。指令 NOT R0 为将寄存器R0的内容取非，这是一个简单的逻辑操作，位运算即可实现，只需要在用户态进行处理，不可能导致CPU从用户态变为内核态。\nD错误。指令 MOV R0, addr 将内存数据加载到寄存器中。虚拟地址空间包括内核与用户空间。其中内核空间供内核使用，用户空间供用户程序使用。在用户态下，应用程序无法直接访问内核空间的内存。如果 addr 所指向的内存地址是用户空间的地址，那么执行 MOV R0, addr 是在用户态进行的，不会导致 CPU 从用户态变为内核态。然而，如果 addr 所指向的内存地址是内核空间的地址，或者是特定的内存映射区域（例如 I/O 地址空间），那么执行 MOV R0, addr 可能需要切换到内核态。在这种情况下，操作系统需要处理这个指令，将 addr 所指向的数据加载到 R0 寄存器中，因此 CPU 可能会切换到内核态执行指令，并在内核态下访问内核空间的内存。\n本题选C。\n【2021-23】下列指令中，只能在内核态执行的是（ ）。\nA. trap指令\nB. I/O指令\nC. 数据传送指令\nD. 设置断点指令\n答案\nA错误。\nB正确。I/O指令（输入/输出指令）是用于进行输入和输出操作的指令。I/O指令只能在内核态下执行。\nC错误。数据传送指令可以在用户态执行。例如将数据从内存复制到寄存器或寄存器之间的传送。\nD错误。设置断点指令可以在用户态执行。例如在调试过程中，用户程序可以设置断点指令来中断程序执行并进行调试操作。\n本题选B。\n【2022-27】下列关于CPU模式的叙述中，正确的是（ ）。\nA. CPU处于用户态时只能执行特权指令\nB. CPU处于内核态时只能执行特权指令\nC. CPU处于用户态时只能执行非特权指令\nD. CPU处于内核态时只能执行非特权指令\n答案\nCPU处于用户态时只能执行非特权指令。CPU处于内核态时即能执行非特权指令也能特权指令。\n本题选C。\n【2023-24】在操作系统内核中，中断向量表适合采用的数据结构是（ ）。\nA. 数组\nB. 队列\nC. 单向链表\nD. 双向链表\n答案\n中断向量表是用于存储中断处理程序入口地址的数据结构。中断向量表的索引对应着中断类型号或中断向量号，而其中存储的值是对应中断类型的处理程序的入口地址。\n使用数组作为中断向量表的数据结构有以下几个优点：\n①快速访问：数组通过索引可以直接定位到对应位置的中断处理程序入口地址，具有常量时间复杂度的访问性能。这是因为中断类型号或中断向量号是连续的整数，可以通过简单的计算得到对应的数组下标。\n②紧凑存储：由于中断类型号或中断向量号是连续的整数，使用数组可以直接按照顺序将中断处理程序的入口地址存储在连续的内存空间中，这样可以节省内存空间。\n因此，中断向量表适合采用数组作为数据结构。\n四个选项中也只有选项A支持随机访问。\n本题选A。\n【2023-26】下列操作完成时，导致CPU从内核态转为用户态的是（ ）。\nA. 阻塞进程\nB. 执行 CPU 调度\nC. 唤醒进程\nD. 执行系统调用\n答案\nA错误。阻塞进程发起时，CPU会由用户态转为内核态，保存当前阻塞进程的上下文到它的PCB里面，然后将该进程的pcb挂到阻塞队列里，至此阻塞完成，CPU还是处于内核态之中，之后调度程序从就绪队列选择一个进程上处理机，进程切换完成之后，才会返回用户态，因此A错误。\nB错误。执行 CPU 调度完成时，还是处于内核态，具体见进程切换那边的详解。\nC错误。在操作系统中，当一个进程发起某种需要等待的操作（如等待I/O操作完成或等待某个信号），它会被标记为睡眠状态，然后被放入等待队列中。当满足等待条件时，操作系统会将进程从等待队列中唤醒，使其重新变为可执行状态。\nD正确。当CPU执行的系统调用完成时，会触发从内核态转换到用户态。在执行系统调用期间，CPU首先会从用户态切换到内核态，然后操作系统执行相应的操作，最后该操作完成时，CPU将再次切换回用户态。系统调用结束后，CPU可以继续执行用户程序。\n本题选D。\n1.3.2 系统调用 系统调用（system call）：应用程序主动向操作系统发出的服务请求\n异常（exception)：非法指令或者其他原因导致当前指令执行失败（如：内存出错）后的处理请求\n中断(hardware interrupt)：来自硬件设备的处理请求\n中断 异常 系统调用 源头 外设 应用程序意想不到的行为 应用程序请求操作系统提供服务 响应方式 异步 同步 异步或同步 处理机制 持续，对用户应用程序透明 杀死进程或者重新执行等 等待和持续 在这个表格中，“响应方式\"指的是触发事件与处理事件之间的时间关系： 异步响应：指中断发生的时间与CPU的指令流无关，是在CPU执行指令的\"任意时刻\"发生的。外设产生的中断是异步的，因为它们可以在CPU执行任何指令期间随时发生。 同步响应：指事件的发生与CPU的指令执行有直接关系，通常是由当前指令执行引起的。异常是同步的，因为它们总是与特定指令的执行直接相关。 系统调用可以是同步的也可以是异步的，这取决于具体的系统调用类型和实现方式。一些系统调用会立即返回结果（同步），而另一些可能会让进程等待直到某个条件满足（异步）。 什么是系统调用，有什么用？\n操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。\n💡 “系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务。\n系统调用与库函数的区别：\n普通应用程序 可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及 编程语言 向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。 操作系统 向上提供系统调用，使得上层程序能请求 裸机 系统调用按照功能分类：应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。\n系统调用的过程：传递系统调用参数→执行陷入指令（用户态）→执行相应的内核请求程序处理系统调用（核心态）→返回应用程序\n详细版：\n注意：\n**注意区分系统调用号和中断类型号，**前者用于标识当前系统调用的类型，后者用于标识当前中断或异常的类型。\n陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态\n发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行\n陷入指令 = trap 指令 = 访管指令 = 自陷指令 = 陷阱指令\n陷入指令引发的异常又称为访管中断\n自陷指令触发异常时保存的断点为下一条指令的地址（若还是该指令的地址，则会陷入死循环）\n额外补充：IA-32+Linux的系统调用：袁《计算机系统基础》\n系统调用是一种特殊的“异常事件”，是操作系统为用户程序提供服务的一种手段。Linux提供了几百种系统调用，主要分为以下几类：进程控制、文件操作、文件系统操作、系统控制、内存管理、网络管理、用户管理和进程通信。系统调用号用整数表示，它用来确定系统调用跳转表中的偏移量。跳转表中每个表项给出相应系统调用对应的系统调用服务例程的首地址。表7.3给出了部分Linux 系统调用的调用号、名称及其含义。\n内核实现的系统调用是以一个软中断的形式（即陷阱指令）来提供的，如果高级语言编写的用户程序直接用陷阱指令来调用系统调用，则会很麻烦，因此，需要将系统调用封装成用户程序能直接调用的函数，如exit()、read()和open()，这些都是标准C库中系统调用对应的封装函数。在用C语言编写的用户程序中，只要用#include命令嵌入相应的头文件，就可以直接使用这些函数来调出操作系统内核中相应的系统调用服务例程，以完成与I/O、文件操作以及进程管理等相关的操作。在本书中将系统调用及对应的封装函数称为系统级函数。\n从C语言编程者角度来看，系统级函数在形式上与普通的应用编程接口（API）以及普通的C语言函数没有差别。但是，实际上它们在机器级代码的具体实现上是不同的。例如，在IA-32+Linux中，**普通函数（包括API）使用CALL指令来实现过程调用，而系统调用则使用陷阱指令来实现。**对于过程调用，执行CALL指令前后，处理器一直在用户态下执行指令，因而，所执行的指令是受限的，所能访问的存储空间也是受限的；而对于系统调用，一旦执行了发出系统调用的陷阱指令，处理器就从用户态转到内核态下运行，此时，CPU可以执行特权指令并访问内核空间。\n实现普通的API以及普通的库函数可能会使用一个或多个系统调用服务功能，也可能不需要使用系统调用服务功能，例如，对于数学库函数，就无须使用系统调用服务功能。**在Linux系统中，系统调用所用的参数通过寄存器传递，而不是像过程调用那样用栈来传递，因此，在封装函数对应的机器级代码中，将使用传送指令把系统调用所需要的参数传送到相应的寄存器。**按照惯例，系统调用号存放在EAX中，传递参数的寄存器顺序依次为：EAX（调用号）、EBX、ECX、EDX、ESI、EDI和EBP，除调用号以外，最多6个参数。若参数个数超出寄存器个数，则将参数块所在存储区的首址放在寄存器中传递。\n封装函数对应的机器级代码有一个统一的结构：总是若干条传送指令后跟上一条陷阱指令。传送指令用来传递系统调用所用的参数，陷阱指令用来陷入内核进行处理。例如，若用户程序希望将字符串“hello，world！”中的14个字符显示在标准输出设备文件stdout上，则可以调用系统调用write(1，“hello，world!”，14），它的封装函数用以下机器级代码（用汇编指令表示）实现。\n在Linux中，有一个系统调用的统一入口，即是系统调用处理程序system_call的首地址，所以，CPU执行指令int$0x80后，便转到system_call的第一条指令开始执行。在system_call中，将根据调用号跳转到当前系统调用对应的系统调用服务例程去执行。system_call执行完后返回到int $0x80指令后面一条指令继续执行。返回参数在EAX中，为整数值，若是正数或0表示成功，负数表示出错码。\n每个系统调用的封装函数都会被转换为一组与具体机器架构相关的指令序列，这个指令序列中至少有一条陷阱指令，在陷阱指令之前可能还有若干条传送指令用于将I/O操作的参数送入相应的寄存器。 例如，在IA-32中，陷阱指令就是INTn指令，也称为软中断指令。在早期IA-32架构中，Linux 系统将int $Ox80指令用作系统调用，在系统调用指令之前会有一串传送指令，用来将系统调用号等参数传送到相应的寄存器。系统调用号通常在EAX寄存器中，内核程序可根据系统调用号选择执行一个系统调用服务例程。这样，用户进程的I/O请求通过调出操作系统中相应的系统调用服务例程来实现。\n系统调用命令经过编译后，形成若干参数和陷入指令！\n1.4 操作系统结构 结构 特性与思想 优点 缺点 分层结构 内核分多层，每层可调用且仅可调用更低一层提供的接口 1. 便于调试和验证，自底向上逐层调试验证 2.易扩展、易维护，各层之间调用接口明确固定 1. 只能调用相邻低层，难以合理定义各层边界 2.效率低，跨层调用受限，系统调用执行时间长 模块化 将内核划分为多个模块，各模块之间通过已定义接口交互；主模块仅保留内核核心功能，可加载内核模块可按需动态装载与卸载 1. 接口清晰，模块可并行开发2.易于维护与扩展，可裁剪性强 3.灵活性高 1. 模块间接口定义与实现较难 2. 模块间可能产生依赖，联调与验证更复杂 宏内核（大内核） 操作系统的大部分功能都放在内核态，常配合\"模块化\"设计思想 1.性能高，内核内各功能可直接相互调用 2. 共享地址空间，调用开销小、效率高 1. 内核庞大复杂，维护困难 2. 某模块出错可能导致整个系统崩溃 微内核 仅保留最基本功能在内核态（如中断与陷入处理、进程/线程管理与调度、基础内存机制、进程间通信），其余功能移到用户态由服务器提供，客户端通过消息传递请求服务 1. 内核小、可靠性高，出错隔离好 2.扩展性与可移植性好，便于支持分布式 3.安全性强 1.性能较差，频繁的用户态/内核态切换与消息传递开销大 2. 用户态模块间不能直接调用，必须经由内核转发 外核（exokernel） 尽量减少抽象层，内核负责资源分配与保护，允许应用直接管理底层硬件资源；应用通常配合库操作系统构建所需抽象 1. 抽象层更薄，减少重映射与中间层开销，效率高 2. 允许应用自定义抽象，灵活性强 1. 系统整体复杂度提高 2.一致性与通用性降低 1.4.1 分层法 分层法是将操作系统分为若干层，最底层（层0）为硬件，最高层（层N）为用户接口，每层只能调用紧邻它的低层的功能和服务（单向依赖）。\nprintf(){ ... char buf[10]; write(4,buf,8); ... } 分层法的优点：①便于系统的调试和验证，简化了系统的设计和实现。第1层可先调试而无须考虑系统的其他部分，因为它只使用了基本硬件。第1层调试完且验证正确之后，就可以调试第2层，如此向上。如果在调试某层时发现错误，那么错误应在这一层上，这是因为它的低层都调试好了。②易扩充和易维护。在系统中增加、修改或替换一层中的模块或整层时，只要不改变相应层间的接口，就不会影响其他层。 分层法的问题：①合理定义各层比较困难。因为依赖关系固定后，往往就显得不够灵活。②效率较差。操作系统每执行一个功能，通常要自上而下地穿越多层，各层之间都有相应的层间通信机制，这无疑增加了额外的开销，导致系统效率降低。 1.4.2 模块化 模块化是将操作系统按功能划分为若干个具有一定独立性的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能通过接口进行通信。还可以进一步将各模块\n细分为若干个具有一定功能的子模块，同样也规定好各子模块之间的接口。把这种设计方法称为模块-接口法，如图所示为由模块、子模块等组成的模块化操作系统结构。\n模块划分问题：\n如果将模块划分得太小，虽然能降低模块本身的复杂性，但会使得模块之间的联系过多，造成系统比较混乱； 如果模块划分得过大，又会增加模块内部的复杂性，显然应在两者间进行权衡。 此外，在划分模块时，要充分考虑模块的独立性问题，因为模块独立性越高，各模块间的交互就越少，系统的结构也就越清晰。衡量模块的独立性主要有两个标准：\n内聚性，模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越好。 耦合度，模块间相互联系和相互影响的程度。耦合度越低，模块独立性越好。 模块化的优点：\n提高了操作系统设计的正确性、可理解性和可维护性； 增强了操作系统的可适应性； 加速了操作系统的开发过程。 模块化的缺点：\n模块间的接口规定很难满足对接口的实际需求。 各模块设计者齐头并进，每个决定无法建立在上一个已验证的正确决定的基础上，因此无法找到一个可靠的决定顺序。 1.4.3 宏内核与微内核 宏内核 思想：宏内核，也称单内核或大内核，是指将系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为用户程序提供高性能的系统服务。目前主流的操作系统，如Windows、Android、iOS、macOS、Linux等，都是基于宏内核的构架。\n目前主流的操作系统早已不是当年纯粹的宏内核构架了，而是广泛吸取微内核构架的优点而后揉合而成的混合内核。\n优点：性能高，内核内部各模块之间信息共享，各种功能都可以直接相互调用，\n与进程都有自己独立的虚拟地址空间不同，内核各程序共享地址空间和各类资源，因此可以很方便地信息共享和相互调用。\n缺点：随着体系结构和应用需求的不断发展，需要操作系统提供的服务越来越复杂，内核庞大功能复杂，结构混乱，难以维护；大内核中某个功能模块出错，就可能导致整个系统崩溃。\n微内核 基于C/S架构的功能模块化设计的操作系统\n思想：微内核构架，是指将内核中最基本的功能保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，从而降低内核的设计复杂性。那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。\n微内核结构将操作系统划分为两大部分：微内核和多个服务器。\n微内核是指精心设计的、能实现操作系统最基本核心功能的小型内核，通常包含：\n①与硬件处理紧密相关的部分； ②一些较基本的功能； ③客户和服务器之间的通信。 这些部分只是为构建通用操作系统提供一个重要基础，这样就可以确保将内核做得很小。 操作系统中的绝大部分功能都放在微内核外的一组服务器（进程）中实现，如用于提供对进程（线程）进行管理的进程（线程）服务器、提供虚拟存储器管理功能的虚拟存储器服务器等，它们都是作为进程来实现的，运行在用户态，客户与服务器之间是借助微内核提供的消息传递机制来实现交互的。下图展示了单机环境下的客户/服务器模式。\n微内核的基本功能\n微内核结构通常利用机制与策略分离的原理来构造OS结构，将机制部分以及与硬件紧密相关的部分放入微内核。微内核通常具有如下功能：\n进程（线程）管理\n进程（线程）之间的通信功能是微内核OS最基本的功能，此外还有进程的切换、进程的调度，以及多处理机之间的同步等功能，都应放入微内核中。举个例子，为实现进程调度功能，需要在进程管理中设置一个或多个进程优先级队列，这部分属于调度功能的机制部分，应将它放入微内核中。而对用户进程如何分类，以及优先级的确认方式，则属于策略问题，可将它们放入微内核外的进程管理服务器中。\n低级存储器管理\n在微内核中，只配置最基本的低级存储器管理机制，如用于实现将逻辑地址变换为物理地址等的页表机制和地址变换机制，这一部分是依赖于硬件的，因此放入微内核。而实现虚拟存储器管理的策略，则包含应采取何种页面置换算法，采用何种内存分配与回收的策略，应将这部分放在微内核外的存储器管理服务器中。\n中断和陷入处理\n微内核OS将与硬件紧密相关的一小部分放入微内核，此时微内核的主要功能是捕获所发生的中断和陷入事件，并进行中断响应处理，在识别中断或陷入的事件后，再发送给相关的服务器来处理，故中断和陷入处理也应放入微内核。\n微内核操作系统将进程管理、存储器管理以及I/O管理这些功能一分为二，**属于机制的很小一部分放入微内核，而绝大部分放入微内核外的各种服务器实现，**大多数服务器都要比微内核大。因此，在采用客户/服务器模式时，能把微内核做得很小。\n优点： 扩展性和灵活性：许多功能从内核中分离出来，当要修改某些功能或增加新功能时，只需在相应的服务器中修改或新增功能，或再增加一个专用的服务器，而无须改动内核代码（内核小功能少，易于维护，内核可靠性高） 可靠性和安全性：只有微内核运行在内核态，其余模块都运行在用户态，**一个模块中的错误只会使这个模块崩溃，而不会使整个系统崩溃。**例如，文件服务代码运行时出了问题，宏内核因为文件服务是运行在内核态的，系统直接就崩溃了。而微内核的文件服务是运行在用户态的，只要把文件服务功能强行停止，然后重启，就可以继续使用，系统不会崩溃。 可移植性：与CPU和I/O硬件有关的代码均放在内核中，而其他各种服务器均与硬件平台无关，因而将操作系统移植到另一个平台上所需做的修改是比较小的。 分布式计算。客户和服务器之间、服务器和服务器之间的通信采用消息传递机制，这就使得微内核系统能很好地支持分布式系统和网络系统。 缺点： 性能差：因为需要频繁地在核心态和用户态之间进行切换，操作系统的执行开销偏大。为了改善运行效率，可以将那些频繁使用的系统服务移回内核，从而保证系统性能，但这又会使微内核的容量明显地增大。 用户态下的各功能模块不能直接相互调用，只有通过内核中的\"消息传递\"来间接通信，性能也因此降低。 虽然宏内核在桌面操作系统中取得了绝对的胜利，但是微内核在实时、工业、航空及军事应用中特别流行，这些领域都是关键任务，需要有高度的可靠性。\n1.4.5 外核 设计思路：尽可能减少抽象层次，允许应用程序直接访问硬件，而ExoKernel只负责保护和分配系统资源。应用程序过来请求资源，Exokernel看看资源是否空闲，如果空闲，直接交给应用，至于应用怎么访问是它自己的事。ExoKernel分离了对硬件的使用和保护，使得应用程序可以直接使用没有经过Kernel抽象的硬件，就很好很强大。 《现代操作系统》：与虚拟机克隆真实机器不同，在这种策略下，是对机器进行分区，换句话说，给每个用户整个资源的一个子集。这样，某个虚拟机可能得到磁盘的0至1023盘块，而另一台虚拟机会得到1024至2047盘块，等等。在底层中，一种称为外核（exokernel）的程序在内核态运行。它的任务是为虚拟机分配资源，并检查使用这些资源的企图，以确保没有机器会使用他人的资源。每个用户层的虚拟机可以运行自己的操作系统，如VM/370和Pentium虚拟8086等，但限制只能使用已经申请并且获得分配的那部分资源。\n外核机制的优点是，它减少了映像层。在其他的设计中，每个虚拟机都认为它有自己的磁盘，其盘块号从0到最大编号，这样虚拟机监控程序必须维护一张表格以重映像磁盘地址（以及其他资源）。有了外核，这个重映像处理就不需要了。外核只需要记录已经分配给各个虚拟机的有关资源即可。这个方法还有一个优点，它将多道程序（在外核内）与用户操作系统代码（在用户空间内）加以分离，而且相应负载并不重，这是因为外核所做的只是保持多个虚拟机彼此不发生冲突。 一些误解澄清\n“外核是极薄的内核：仅负责资源保护与分配，并将抽象与策略下放到用户态的库操作系统；它仍运行在内核态的软件层，而非专用硬件。”\n1.5 操作系统引导 推荐阅读：\n下面主要引用自 阮一峰计算机是如何启动的？ 你知道那个帮你叫醒主机的BIOS，究竟是怎么发展而来的吗【BIOS发展史】 可以看一下b站的这个视频：2.了解计算机的启动过程和主引导扇区，让你的计算机从这里起飞吧 从开机到引导操作系统的详细过程包含Linux代码详解 清华大学操作系统的启动 维基百科BIOS、主引导记录MBR、引导程序 boot的含义：先问一个问题，“启动”用英语怎么说？\n回答是boot。可是，boot原来的意思是靴子，“启动”与靴子有什么关系呢？ 原来，这里的boot是bootstrap（鞋带）的缩写，它来自一句谚语：“pull oneself up by one’s bootstraps”字面意思是”拽着鞋带把自己拉起来”，这当然是不可能的事情。最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！\n早期真的是这样，必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。所以，工程师们把这个过程叫做”拉鞋带”，久而久之就简称为boot了。\n1. 第一阶段：BIOS 上个世纪70年代初，“只读内存”（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。\n这块芯片里的程序叫做\"基本输入输出系統”（Basic Input/Output System），简称为BIOS。\n1.1 上电及硬件自检\n按下电脑上的电源按钮上电后, CPU的RESET引脚会产生一个逻辑值来复位CPU, CPU唤醒后, CPU将在0xfffffff0处执行一条长跳转指令, 直接跳到固化在ROM中的启动代码处(即BIOS), 将其加载到RAM，然后执行BIOS的代码.\nBIOS中主要存放的程序包括：\n自诊断程序（通过读取CMOS RAM中的内容识别硬件配置，并对其进行自检和初始化） CMOS设置程序（引导过程中，通过特殊热键启动，进行设置后，存入CMOS RAM中） 系统自动装载程序（在系统自检成功后，将磁盘相对0道0扇区上的引导程序装入内存使其运行） 主要I/O驱动程序和中断服务（BIOS和硬件直接打交道，需要加载I/O驱动程序） BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做\"硬件自检\"（Power-On Self-Test），缩写为POST。\n如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。\n1.2 启动顺序\n硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。\n这时，BIOS需要知道，“下一阶段的启动程序\"具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做\"启动顺序”（Boot Sequence）。\n打开BIOS的操作界面，里面有一项就是\"设定启动顺序\"。\n2. 第二阶段：主引导记录 BIOS按照\"启动顺序\"，把控制权转交给排在第一位的储存设备。即根据用户指定的引导顺序从软盘、硬盘或是可移动设备中读取启动设备的MBR，并放入指定的位置（0x7c000）内存中。(BIOS的最后一个任务)\n这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA(用来标识该磁盘是否为引导磁盘)，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给\"启动顺序\"中的下一个设备。\n为什么是0x55和0xaa? 因为aa展开为10101010, 55展开为01010101,变成串行电平的话就是一个占空比为50%的方波， 这种方波在电路中最容易被分辨是否受干扰或者畸变.\n这最前面的512个字节，就叫做**“主引导记录”**（Master boot record，缩写为MBR）。\n2.1 主引导记录MBR的结构\n“主引导记录\"只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。\n主引导记录由三个部分组成：\n（1） 第1-446字节：调用操作系统的机器码。 （2） 第447-510字节：分区表（Partition table）。 （3） 第511-512字节：主引导记录签名（0x55和0xAA）。 其中，第二部分”分区表“的作用，是将硬盘分成若干个区。\n2.2 分区表\n硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，“主引导记录\"因此必须知道将控制权转交给哪个区。\n分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做\"主分区”。\n每个主分区的16个字节，由6个部分组成：\n（1）第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。 （2）第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。 （3）第5个字节：主分区类型。 （4）第6-8个字节：主分区最后一个扇区的物理位置。 （5）第9-12字节：该主分区第一个扇区的逻辑地址。 （6）第13-16字节：主分区的扇区总数。\n最后的四个字节（“主分区的扇区总数”），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。\n如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。\n3. 第三阶段:硬盘启动 这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。\n3.1 情况A：要引导的操作系统位于主分区(后两种不要求掌握)\n上一节提到，四个主分区里面，只有一个是激活的。计算机会读取**激活分区(活动分区)**的第一个扇区，叫做”卷引导记录\"（Volume boot record，缩写为VBR）。\n王道书里把这个扇区称为\"分区引导记录PBR\"\n3.2 情况B：位于扩展分区和逻辑分区\n随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成\"扩展分区\"（Extended partition）。\n所谓\"扩展分区\"，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做\"逻辑分区\"（logical partition）。\n计算机先读取扩展分区的第一个扇区，叫做\"扩展引导记录\"（Extended boot record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。\n计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。\n但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。\n3.3 情况C：启动管理器\n在这种情况下，计算机读取\"主引导记录\"前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的\"启动管理器\"（boot loader），由用户选择启动哪一个操作系统。\nLinux环境中，目前最流行的启动管理器是Grub。\n4. 第四阶段：操作系统 分区引导记录PBR找到引导操作系统的程序后， 控制权转交给操作系统，操作系统的内核首先被载入内存。\n以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。\n然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。\n至此，全部启动过程完成。\n计算机开机时，操作系统所处的位置是（D）\nA、内存 ROM\nB、内存 RAM\nC、磁盘主引导扇区\nD、以上都不对\n解析:计算机开机后，先执行 ROM 中的引导程序，将主引导扇区 MBR 中的程序放入内存中执行，再通过该程序去将操作系统程序装入内存中并移交 cpu 控制权给操作系统，因此答案选 D\n磁盘管理+安装OS+OS引导+OS初始化\n单独的操作系统引导示意图\n【小贴士】：实地址模式（Real Mode)是Intel为80286及其之后的处理器提供的一种8086兼容模式。采用20位存储器地址空间，即可寻址空间为1MB，不支持分页存储管理机制。每个存储单元地址由16位段地址左移4位后与16位偏移量相加而得到。\n开机后系统首先在实地址模式下工作 因此，开机过程中，需要先准备在实地址模式下的中断向量表和中断服务程序。通常，这个准备工作是由固化在计算机主板上的一块ROM芯片中的BIOS程序来完成的。 BIOS程序首先检测显卡、键盘、内存等，并在主存的00000H~003FFH区域建立中断向量表，同时，在中断向量所指的主存区域建立相应的中断服务程序 BIOS利用INT指令执行特定的中断服务程序可以把操作系统内核程序从磁盘加载到内存中。例如，BIOS可以通过执行指令int0x19来调用中断向量0x19对应的中断服务程序，将启动盘上的0号磁头对应盘面的0磁道1扇区中的引导程序装入内存。 BIOS(Basic Input/Output System）是基本输入/输出系统的简称，是针对具体的主板设计的，与安装的操作系统无关。 BIOS中包含了各种基本设备的驱动程序，通过执行BIOS程序，这些基本设备驱动程序以中断服务程序的形式被加载到内存中，以提供基本I/O系统调用。一旦进入保护模式，就不再使用BIOS。 摘自袁春风《计算机系统基础》\n1.6 虚拟机 虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器（Virtual Machine, VM），每个虚拟机器都可以独立运行一个操作系统\n同义术语：虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor/Hypervisor\n提供虚拟机管理程序并不属于操作系统的任务，第二类虚拟机管理程序是一种应用程序。\n1.6.1 第一类虚拟机管理程序(裸金属架构) 从技术上讲，第一类虚拟机管理程序就像一个操作系统，因为它是唯一一个运行在最高特权级的程序。它在裸机上运行并且具备多道程序功能。虚拟机管理程序向上层提供若干台虚拟机，这些虚拟机是裸机硬件的精确复制品。由于每台虚拟机都与裸机相同，所以在不同的虚拟机上可以运行任何不同的操作系统。图中显示了第一类虚拟机管理程序。\n虚拟机作为用户态的一个进程运行，不允许执行敏感指令。然而，虚拟机上的操作系统认为自己运行在内核态（实际上不是），称为虚拟内核态。虚拟机中的用户进程认为自己运行在用户态（实际上确实是)。当虚拟机操作系统执行了一条CPU处于内核态才允许执行的指令时，会陷入虚拟机管理程序。在支持虚拟化的CPU上，虚拟机管理程序检查这条指令是由虚拟机中的操作系统执行的还是由用户程序执行的。如果是前者，虚拟机管理程序将安排这条指令功能的正确执行。否则，虚拟机管理程序将模拟真实硬件面对用户态执行敏感指令时的行为。 在过去不支持虚拟化的CPU上，真实硬件不会直接执行虚拟机中的敏感指令，这些敏感指令被转为对虚拟机管理程序的调用，由虚拟机管理程序模拟这些指令的功能。\n第一类虚拟机执行一条特权指令的过程 指令执行尝试：在虚拟机内部，操作系统（虚拟操作系统）尝试执行一条特权指令。由于虚拟操作系统运行在虚拟内核态，它认为自己有权执行此类指令。 指令截获：虚拟机中执行的特权指令被虚拟机管理程序（hypervisor）截获。在具备硬件虚拟化支持的现代CPU中，这通常通过硬件辅助的特性（如Intel的VT-x或AMD的AMD-V）实现。这些技术使得CPU能够在尝试执行特权指令时，自动将控制权转交给虚拟机管理程序。 检查与执行：虚拟机管理程序接收到控制权后，首先确定指令的来源是虚拟操作系统还是虚拟机内的一个用户程序。如果确认是虚拟操作系统发出的特权指令，虚拟机管理程序将按照指令的要求，利用它对硬件的直接控制能力，来安全地执行该指令。 模拟行为：如果该特权指令是由用户程序错误地尝试执行的，则虚拟机管理程序会模拟硬件对非法特权指令执行的响应，通常是通过抛出异常或错误处理。 返回控制权：指令执行完毕后，虚拟机管理程序将控制权返回给虚拟机，使得虚拟机操作系统或应用程序可以继续运行。 1.6.2 第二类虚拟机管理程序(寄居架构) 图中显示了第二类虚拟机管理程序。**它是一个依赖于Windows、Linux等操作系统分配和调度资源的程序，很像一个普通的进程。**第二类虚拟机管理程序仍然伪装成具有CPU和各种设备的完整计算机。VMware Workstation 是首个X86平台上的第二类虚拟机管理程序。\n运行在第二类虚拟机管理程序上的操作系统都称为客户操作系统。对于第二类虚拟机管理程序，运行在底层硬件上的操作系统称为宿主操作系统。\n第二类虚拟机管理程序负责将虚拟机程序的虚拟地址转换为宿主操作系统中的虚拟地址（该虚拟地址在虚拟机 OS 看来是\"物理地址\"），再由宿主操作系统转换为真正的物理地址。\n首次启动时，第二类虚拟机管理程序像一台刚启动的计算机那样运转，期望找到的驱动器可以是虚拟设备。然后将操作系统安装到虚拟磁盘上（其实只是宿主操作系统中的一个文件）。客户操作系统安装完成后，就能启动并运行。\n虚拟化在Web主机领域很流行。没有虚拟化，服务商只能提供共享托管（不能控制服务器的软件）和独占托管（成本较高）。当服务商提供租用虚拟机时，一台物理服务器就可以运行多个虚拟机，每个虚拟机看起来都是一台完整的服务器，客户可以在虚拟机上安装自己想用的操作系统和软件，但是只需支付较低的费用。这就是市面上常见的“云”主机。\n对比项 第一类 VMM 第二类 VMM 对物理资源的控制权 直接运行在硬件之上，能直接控制和分配物理资源 运行在Host OS之上，依赖 Host OS为其分配物理资源 资源分配方式 安装Guest OS时，VMM在硬盘上为其分配存储空间，类似\"外接\"方式，直接分配未经抽象的物理硬件 GuestOS拥有自己的虚拟磁盘，该磁盘实际是Host OS文件系统中的一个文件；GuestOS分配到的内存是虚拟内存 性能 性能更好 性能更差，需要Host OS作为\"中介\" 可支持的虚拟机数量 更多；不需要和Host OS竞争资源，相同硬件资源可支持更多虚拟机 更少；Host OS本身要使用物理资源，Host OS上运行的其他进程也需要物理资源 虚拟机的可迁移性 更差 更好；只需导出虚拟机镜像文件即可迁移到另一台HostOS上，商业化应用更广 运行模式 运行在最高特权级（Ring 0），可执行最高特权指令 部分运行在用户态，部分运行在内核态；GuestOS发出的系统调用会被VMM截获，转化为对HostOS的系统调用 ",
  "wordCount" : "1001",
  "inLanguage": "en",
  "datePublished": "2025-12-30T12:00:00+08:00",
  "dateModified": "2025-12-30T12:00:00+08:00",
  "author":{
    "@type": "Person",
    "name": "Twojian"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://twojian.github.io/posts/blog/%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Twojian Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://twojian.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://twojian.github.io/" accesskey="h" title="Twojian&#39;s Home (Alt + H)">Twojian&#39;s Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://twojian.github.io/search/" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://twojian.github.io/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="https://twojian.github.io/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://twojian.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://twojian.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://twojian.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      408|操作系统笔记：第一章 操作系统概述
    </h1>
    <div class="post-description">
      操作系统核心概念和发展
    </div>
    <div class="post-meta"><span title='2025-12-30 12:00:00 +0800 +0800'>2025-12-30</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>1001 words</span>&nbsp;·&nbsp;<span>Twojian</span>&nbsp;|&nbsp;<span>
    <a href="https://github.com/twojian/twojian.github.io/tree/main/content/posts/blog/%e7%ac%ac%e4%b8%80%e7%ab%a0%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%a6%82%e8%bf%b0.md" rel="noopener noreferrer edit" target="_blank">Suggest Changes</a>
</span>

</div>
  </header> 
  <div class="post-content"><h1 id="第一章操作系统概述">第一章操作系统概述<a hidden class="anchor" aria-hidden="true" href="#第一章操作系统概述">#</a></h1>
<h2 id="第一章操作系统概述-1">第一章 操作系统概述<a hidden class="anchor" aria-hidden="true" href="#第一章操作系统概述-1">#</a></h2>
<p><strong>【考频统计】</strong></p>
<table>
  <thead>
      <tr>
          <th>年份</th>
          <th>考点</th>
          <th>分值</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2009</td>
          <td>并发与并行（批处理系统）</td>
          <td>2分</td>
      </tr>
      <tr>
          <td>2010</td>
          <td>系统调用</td>
          <td>2分</td>
      </tr>
      <tr>
          <td>2011</td>
          <td>操作系统运行机制（用户态、内核态）</td>
          <td>2分</td>
      </tr>
      <tr>
          <td>2012</td>
          <td>操作系统运行机制（用户态、内核态）</td>
          <td>2分</td>
      </tr>
      <tr>
          <td>2013</td>
          <td>操作系统运行机制（用户态、内核态）、操作系统引导、系统调用</td>
          <td>23 = 6分</td>
      </tr>
      <tr>
          <td>2014</td>
          <td>操作系统运行机制（用户态、内核态）</td>
          <td>2分</td>
      </tr>
      <tr>
          <td>2015</td>
          <td>操作系统运行机制（用户态、内核态）</td>
          <td>2分</td>
      </tr>
      <tr>
          <td>2016</td>
          <td>批处理系统</td>
          <td>2分</td>
      </tr>
      <tr>
          <td>2017</td>
          <td>系统调用、批处理系统</td>
          <td>22=4分</td>
      </tr>
      <tr>
          <td>2018</td>
          <td>批处理系统</td>
          <td>2分</td>
      </tr>
      <tr>
          <td>2019</td>
          <td>系统调用</td>
          <td>2分</td>
      </tr>
      <tr>
          <td>2020</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>2021</td>
          <td>操作系统运行机制（用户态、内核态）、系统调用</td>
          <td>22=4分</td>
      </tr>
      <tr>
          <td>2022</td>
          <td>批处理系统、操作系统引导(初始化)、操作系统运行机制（用户态、内核态）、系统调用</td>
          <td>42=8分</td>
      </tr>
      <tr>
          <td>2023</td>
          <td>宏内核与微内核、操作系统运行机制（用户态、内核态）</td>
          <td>22=4分</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>【考点分析】：注意到用户态与内核态这个知识点考察了8次、系统调用考察了6次、批处理系统（多道程序设计）考察了5次，这几个知识点必须弄得十分清楚！！！此外，异常与中断这个知识点也超级重要，另见单独章节！！！</p>
<p>【系统调用的完整过程必须要弄清楚】：大题隐藏考点</p>
</blockquote>
<h2 id="11-操作系统的基本概念">1.1 操作系统的基本概念<a hidden class="anchor" aria-hidden="true" href="#11-操作系统的基本概念">#</a></h2>
<h3 id="111-操作系统的概念">1.1.1 操作系统的概念<a hidden class="anchor" aria-hidden="true" href="#111-操作系统的概念">#</a></h3>
<p>操作系统（<code>Operating System，OS</code>）是指控制和管理整个计算机系统的<strong>硬件和软件</strong>资源(是系统资源的管理者)，并合理地组织调度计算机的工作和资源的分配；以<strong>提供给用户和其他软件方便的接口和环境</strong>(向上层提供方便易用的服务)；它是计算机系统中最基本的<strong>系统软件</strong>（最接近硬件的一层软件）。</p>
<h3 id="112-操作系统的特征">1.1.2 操作系统的特征<a hidden class="anchor" aria-hidden="true" href="#112-操作系统的特征">#</a></h3>
<p><strong>1. 并发(Concurrence)</strong></p>
<ul>
<li>指两个或多个事件在<strong>同一时间间隔内</strong>发生(<strong>引入进程</strong>的目的就是使程序可以并发执行)</li>
<li>这些事件<strong>宏观上是同时发生的，但微观上是交替发生的</strong>(通过分时实现)</li>
</ul>
<p>常考易混概念——并行：指两个或多个事件在<strong>同一时刻</strong>同时发生。</p>
<p>操作系统就是伴随着&quot;多道程序技术&quot;而出现的。因此，操作系统和程序并发是一起诞生的。</p>
<blockquote>
<p>【注】：并行性是指系统具有同时进行运算或操作的特性，在同一时刻能完成多种工作。并行性需要有相关硬件的支持，如多流水线或多处理机硬件环境。</p>
</blockquote>
<p><strong>2. 共享(Sharing)</strong></p>
<p>即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<p>共享方式：</p>
<ul>
<li>互斥共享方式：系统中的某些资源，虽然可以提供多个进程使用，但<strong>一个时间段内只允许一个进程</strong>访问该资源。</li>
</ul>
<blockquote>
<p>适用于打印机、磁带机等大多数物理设备，某些软件中使用的栈、变量和表格等临界资源</p>
</blockquote>
<ul>
<li>同时共享(访问)方式：系统中的某些资源，允许<strong>一个时间段内由多个进程&quot;同时&quot;对它们进行访问</strong>，所谓的&quot;同时&quot;往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</li>
</ul>
<blockquote>
<p>适用于磁盘设备、用重入码编写的文件等资源</p>
</blockquote>
<p>**如何判断是互斥还是同时访问：**如果若干进行交替使用设备对结果没有影响，则需同时访问方式(如磁盘)，如果会产生影响，则要互斥访问(如打印机等)；</p>
<p>生活实例：</p>
<ul>
<li>互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。</li>
<li>同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的</li>
</ul>
<blockquote>
<p>并发性指计算机系统中同时存在着多个运行着的程序。<strong>共享性</strong>是指系统中的资源可供内存中多个并发执行的进程共同使用。
<strong>并发和共享的关系：二者是操作系统最基本的特征，互为存在的条件：</strong>
①资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题；
②若系统不能对资源贡献实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。</p>
</blockquote>
<p><strong>3. 虚拟(Virtual)</strong></p>
<p>虚拟是指把<strong>一个</strong>物理上的实体变为<strong>若干个</strong>逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p>
<blockquote>
<p>虚拟处理器：通过多道程序设计技术，让其并发执行来分时使用一个处理器；(时分复用技术，微观上处理机在各个微小的时间段内交替着为各个进程服务)
虚拟存储器：利用覆盖、交换、请求分页/分段/段页等技术逻辑上扩充存储器的容量；(空分复用技术)
虚拟设备：<code>SPOOLing</code>技术将一台物理I/O设备虚拟为多台逻辑上的I/O设备。</p>
</blockquote>
<p>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性</p>
<p><strong>4. 异步(Asynchronism)</strong></p>
<p>在多道程序环境下，允许多个程序并发执行，由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停，<strong>以不可预知的速度向前推进</strong>，这就是进程的异步性。</p>
<blockquote>
<p>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。</p>
</blockquote>
<hr>
<h3 id="113-操作系统的功能和目标">1.1.3 操作系统的功能和目标<a hidden class="anchor" aria-hidden="true" href="#113-操作系统的功能和目标">#</a></h3>
<ol>
<li>
<p><strong>作为系统资源的管理者</strong>(对应着后面四章)</p>
<ul>
<li><strong>处理机管理</strong>：即分配和控制处理机，主要包括了进程控制、进程同步、进程通信、调度等</li>
<li><strong>存储器管理</strong>：主要有内存分配、内存保护、地址映射、虚拟存储等</li>
<li><strong>设备管理</strong>：包括缓冲管理、设备分配、设备驱动等</li>
<li><strong>文件管理</strong>：包括文件存储空间的管理、目录管理、文件的读/写管理和保护等</li>
</ul>
</li>
<li>
<p><strong>作为用户与计算机硬件系统之间的接口</strong></p>
</li>
</ol>
<p>封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。</p>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100961676-b797c738-c4f5-4ea7-9649-e4944db0fcb4-231239.png" alt=""></p>
<ul>
<li><strong>命令接口</strong>：用户利用这些操作命令来组织和控制作业的执行；
<ul>
<li>
<p><strong>联机命令接口</strong>：即交互式命令接口，适用于分时或实时系统 ；说一句干一句；</p>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100961595-319aee65-ae06-4977-be99-0b475df9c49c-782795.png" alt=""></p>
</li>
<li>
<p><strong>脱机命令接口</strong>：批处理命令接口，适用于批处理系统，由一组控制命令组成 ；提供一个事情清单，一条一条完成；</p>
</li>
</ul>
</li>
<li><strong>程序接口：<strong>由一组</strong>系统调用</strong>(也称广义指令)组成。用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，如使用各种外部设备、申请分配和回收内存及其他要求；例如图形用户接口GUI。</li>
</ul>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100961646-0226d600-7ad4-4900-b3c8-d5140e52f99c-620232.png" alt=""></p>
<ol>
<li>
<p><strong>实现对计算机资源的抽象(扩充)</strong>：</p>
 <aside>
 💡
<p>没有任何软件支持的计算机称为裸机，它仅构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。裸机在最里层，其外面是操作系统。操作系统所提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器：因此，我们通常把覆盖了软件的机器称为扩充机器或虚拟机。</p>
 </aside>
</li>
</ol>
<hr>
<h2 id="12-操作系统发展历程">1.2 操作系统发展历程<a hidden class="anchor" aria-hidden="true" href="#12-操作系统发展历程">#</a></h2>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100961718-cb973277-618a-43ba-a6d0-2b42f7bcec52-877191.png" alt="image-20230705170331702.png"></p>
<h3 id="121-手工操作阶段">1.2.1 手工操作阶段<a hidden class="anchor" aria-hidden="true" href="#121-手工操作阶段">#</a></h3>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100961605-36ed6c55-6a03-4beb-8936-8bf785b83a95-128085.png" alt=""></p>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1745217851973-d8591279-2614-4543-8fc7-307c65d97754-251196.png" alt=""></p>
<p>缺点：用户独占全机，资源利用率极低；CPU等待手工操作，利用不充分</p>
<h3 id="122-批处理阶段">1.2.2 批处理阶段<a hidden class="anchor" aria-hidden="true" href="#122-批处理阶段">#</a></h3>
<p>引入<strong>脱机输入/输出技术</strong>（用外围机+磁带完成），并由监督程序负责控制作业的输入、输出</p>
<ol>
<li>
<p><strong>单道批处理系统</strong>：系统对作业的处理是成批进行的，但内存中**始终保持一道作业；**是在解决人机矛盾及CPU和I/O设备速率不匹配的矛盾中形成的；</p>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100961714-2eb24b3c-a6b0-4508-9833-d559c442cd95-875569.png" alt=""></p>
</li>
</ol>
<ul>
<li><strong>特点</strong>：
<ul>
<li>自动性：磁带上的一批作业自动逐个运行，而无须人工干预，缓解了一定程度的人机速度矛盾，资源利用率有所提升。</li>
<li>顺序性：各道作业<strong>顺序进入内存，顺序完成；</strong></li>
<li>单道性：内存中<strong>仅能有一道程序运行</strong>，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I/O完成，资源利用率依然很低。</li>
</ul>
</li>
</ul>
<ol>
<li>
<p><strong>多道批处理系统</strong>：每次往内存中读入多道程序，作业成批运行</p>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100961624-659b84ef-cdc8-4404-957f-f049821a61e4-618226.png" alt="image-20230705161304632.png"></p>
</li>
</ol>
<ul>
<li><strong>主要优点</strong>：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持&quot;忙碌&quot;状态，系统吞吐量增大</li>
<li><strong>主要缺点</strong>：<strong>用户响应时间长</strong>，<strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。eg：无法调试程序/无法在程序运行过程中输入一些参数）</li>
</ul>
<blockquote>
<p>多道程序设计技术（多任务又名多道程序）：允许多个程序同时进入内存并允许它们在CPU中交替地运行，这些程序共享系统中的各种硬/软件资源。当一道程序因I/O请求而暂停运行时，借助中断技术CPU便立即转去运行另一道程序。它不采用某些机制来提高某一技术方面的瓶颈问题，而让系统的各个组成部分都尽量去&quot;忙&quot;，因此切换任务所花费的时间很少，可实现系统各部件之间的并行工作，使其整体在单位时间内的效率翻倍。当然，多道批处理系统的设计和实现要比单道系统复杂很多，因为要充分利用各种资源，就要涉及各种资源的调度问题。多道程序设计的特点：</p>
<ul>
<li>多道，计算机内存中同时存放多道相互独立的程序。</li>
<li>宏观上并行，同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行，但都未运行完毕</li>
<li>微观上串行，内存中的多道程序轮流占有CPU，交替执行。</li>
</ul>
<p>多道程序设计技术的实现需要解决下列问题：</p>
<ul>
<li>如何分配处理器。</li>
<li>多道程序的内存分配问题。</li>
<li>I/O设备如何分配。</li>
<li>如何组织和存放大量的程序和数据，以方便用户使用并保证其安全性与一致性。</li>
</ul>
</blockquote>
<h3 id="123-分时操作系统">1.2.3 分时操作系统<a hidden class="anchor" aria-hidden="true" href="#123-分时操作系统">#</a></h3>
<p>计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。</p>
<ul>
<li>主要优点：用户请求可以被<strong>及时</strong>响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作<strong>相互独立</strong>，感受不到别人的存在。</li>
<li>主要缺点：<strong>不能优先处理一些紧急任务</strong>(不能在比时间片还短的时间内快速做出反应)，操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。</li>
</ul>
<hr>
<h3 id="124-实时操作系统">1.2.4 实时操作系统<a hidden class="anchor" aria-hidden="true" href="#124-实时操作系统">#</a></h3>
<p>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。</p>
<p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是<strong>及时性和可靠性</strong></p>
<ul>
<li><strong>硬实时系统</strong>：必须保证让某个特定的动作在规定的时间内完成；如导弹制导、自动驾驶等</li>
<li><strong>软实时系统</strong>：若能够接受偶尔违反时间规定且不会引起任何永久性的损害； 如12315订票系统、银行管理系统等</li>
</ul>
<hr>
<h3 id="125-网络操作系统和分布式计算机系统">1.2.5 网络操作系统和分布式计算机系统<a hidden class="anchor" aria-hidden="true" href="#125-网络操作系统和分布式计算机系统">#</a></h3>
<ul>
<li><strong>网络操作系统</strong>是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，<strong>实现网络中各种资源的共享</strong>（如文件共享）和<strong>各台计算机之间的通信</strong>。（如：<code>Windows NT</code> 就是一种典型的网络操作系统，网站服务器就可以使用)</li>
<li><strong>分布式操作系统</strong>：主要特点是<strong>分布性</strong>和<strong>并行性</strong>。系统中的<strong>各台计算机地位相同</strong>，任何工作都可以分布在这些计算机上，<strong>由它们并行、协同完成这个任务。</strong></li>
</ul>
<hr>
<h3 id="126-个人操作系统">1.2.6 个人操作系统<a hidden class="anchor" aria-hidden="true" href="#126-个人操作系统">#</a></h3>
<p>个人计算机操作系统是目前使用最广泛的操作系统，它广泛应用于文字处理、电子表格、游戏中，常见的有 <code>Windows</code>、<code>Linux</code>和<code>MacOS</code>等。</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">timeline
  title 操作系统发展简表
  手工阶段       : 独占资源，利用率低
  脱机处理       : 外围机+磁带，减小CPU空闲
  早期批处理     : 提升CPU利用
  多道批处理     : 宏观并行、微观串行
  分时操作系统   : 时间片轮转，交互强
  实时操作系统   : 及时性、可靠性
  网络操作系统   : 资源共享与通信
  分布式操作系统 : 建立在网络OS上，控制分布化
  个人计算机   : 普及最广
</code></pre><blockquote>
<p>资源利用率：批处理 &gt; 分时 &gt; 实时
<strong>交互性</strong>： 分时 &gt; 实时 &gt; 批处理
<strong>及时性</strong>：实时 &gt; 分时 &gt; 批处理
<strong>可靠性</strong>：实时(最强)
<strong>分时</strong>：实现了人机交互的功能
<strong>批处理</strong>：实现了作业自动运行控制的功能</p>
</blockquote>
<h3 id="127-该考点真题">1.2.7 该考点真题<a hidden class="anchor" aria-hidden="true" href="#127-该考点真题">#</a></h3>
<p>【2009-23】单处理机系统中，可并行的是（ ）。</p>
<p>Ⅰ. 进程与进程</p>
<p>Ⅱ. 处理机与设备</p>
<p>Ⅲ. 处理机与通道</p>
<p>Ⅳ. 设备与设备</p>
<p>A. Ⅰ、Ⅱ和Ⅲ</p>
<p>B. Ⅰ、Ⅱ和Ⅳ</p>
<p>C. Ⅰ、Ⅲ和Ⅳ</p>
<p>D. Ⅱ、Ⅲ和Ⅳ</p>
<ul>
<li>
<p>答案</p>
<p>单处理机系统（不包含多核的情况）中，同一时刻只能有一个进程占用处理机，因此进程之间不能并行执行，只能串行执行。I错误。</p>
<p>设备独立于处理机，两者可以并行。II正确。</p>
<p>通道是独立于处理机的控制输入/输出的设备，两者可以并行。III正确。</p>
<p>设备与设备之间相互独立，可以并行。IV正确。</p>
<p>综上，Ⅱ、Ⅲ和Ⅳ正确。</p>
<p>本题选D。</p>
</li>
</ul>
<p>【2016-23】下列关于批处理系统的叙述中，正确的是（ ）。</p>
<p>Ⅰ.批处理系统允许多个用户与计算机直接交互</p>
<p>Ⅱ.批处理系统分为单道批处理系统和多道批处理系统</p>
<p>Ⅲ.中断技术使得多道批处理系统的I/O设备可与CPU并行工作</p>
<p>A. 仅Ⅱ、Ⅲ</p>
<p>B. 仅Ⅱ</p>
<p>C.仅Ⅰ、Ⅱ</p>
<p>D. 仅Ⅰ、Ⅲ</p>
<ul>
<li>
<p>答案</p>
<p>I错误。批处理系统是一种处理方式，其中用户将一批作业提交给计算机系统，而不是直接与计算机进行交互。在批处理系统中，作业按照预定的顺序依次执行，而不需要用户的干预。</p>
<p>II正确。批处理系统分为单道批处理系统和多道批处理系统。单道批处理系统是最早的批处理系统，它一次只能执行一个作业。多道批处理系统则允许多个作业同时加载到内存中，可以并行执行，提高了系统的资源利用率。</p>
<p>III正确。中断是一种计算机系统中的事件通知机制，可以打断CPU正在执行的程序，并转而处理其他任务。在多道批处理系统中，当一个作业的I/O操作开始时，CPU可以切换到另一个作业进行处理，从而实现I/O设备和CPU的并行工作，提高了系统的吞吐量。</p>
<p>综上，仅Ⅱ、Ⅲ正确。本题选A。</p>
</li>
</ul>
<p>【2017-28】与单道程序系统相比，多道程序系统的优点是（ ）。</p>
<p>Ⅰ. CPU利用率高</p>
<p>Ⅱ. 系统开销小</p>
<p>Ⅲ. 系统吞吐量大</p>
<p>Ⅳ. I/O设备利用率高</p>
<p>A. 仅Ⅰ、Ⅲ</p>
<p>B. 仅Ⅰ、Ⅳ</p>
<p>C. 仅Ⅱ、Ⅲ</p>
<p>D. 仅Ⅰ、Ⅲ、Ⅳ</p>
<ul>
<li>
<p>答案</p>
<p>Ⅰ正确。多道程序系统能够同时运行多个程序，通过进程切换和时间片轮转等调度算法，实现了多个程序的并发执行。这样可以充分利用CPU资源，提高CPU的利用率。</p>
<p>Ⅱ错误。多道程序系统要付出额外的开销来组织作业和切换作业。</p>
<p>Ⅲ正确。多道程序系统能够同时处理多个程序，从而提高了系统的吞吐量。</p>
<p>Ⅳ正确。多道程序系统能够同时处理多个程序的I/O请求。当一个程序在等待一个I/O操作完成时，系统可以切换到另一个程序，继续执行其他任务，从而提高了I/O设备的利用率。</p>
<p>综上，仅Ⅰ、Ⅲ、Ⅳ正确。</p>
<p>本题选D。</p>
</li>
</ul>
<p>【2018-23】下列关于<strong>多任务操作系统</strong>的叙述中，正确的是（ ）。</p>
<p>Ⅰ. 具有并发和并行的特点</p>
<p>Ⅱ. 需要实现对共享资源的保护</p>
<p>Ⅲ. 需要运行在多CPU的硬件平台上</p>
<p>A. 仅Ⅰ</p>
<p>B. 仅Ⅱ</p>
<p>C. 仅Ⅰ、Ⅱ</p>
<p>D. Ⅰ、Ⅱ、Ⅲ</p>
<ul>
<li>
<p>答案</p>
<p>I正确。多任务操作系统具有并发和并行的特点，可以同时执行多个任务或进程，并能够充分利用多核CPU或多个CPU进行并行处理。</p>
<p>II正确。由于多个任务或进程可能会竞争使用共享资源（如内存、硬盘等），因此需要实现对共享资源的保护。</p>
<p>III错误。需要运行在多CPU的硬件平台上并不是必要条件，多任务操作系统可以在单CPU的硬件平台上运行，只是在多CPU的硬件平台上可以更好地发挥并行处理的能力。现代操作系统（如：Windows、Linux、Mac OS X等）允许同时运行多个进程，分时操作系统分配给每个正在运行的进程微观上的一段CPU时间，称为时间片，在只考虑一个CPU的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短，用户不会感觉到。</p>
<p>综上，仅Ⅰ、Ⅱ正确。</p>
<p>本题选C。</p>
</li>
</ul>
<p>【2022-23】下列关于多道程序系统的叙述中，不正确的是（ ）。</p>
<p>A. 支持进程的并发执行</p>
<p>B. 不必支持虚拟存储管理</p>
<p>C. 需要实现对共享资源的管理</p>
<p>D. 进程数越多CPU利用率越高</p>
<ul>
<li>
<p>答案</p>
<p>A正确。多道程序系统可以同时（宏观上）运行多个进程，使它们在系统中并发执行。</p>
<p>B正确。在计算机的早期，多道程序系统中CPU一次读取多个程序放入内存，不必支持虚拟存储管理。</p>
<p>C正确。在多道程序系统中，多个进程可能同时访问和使用共享资源，如内存、文件系统、设备等。为了避免冲突和资源竞争，操作系统需要实现对共享资源的管理，例如使用锁机制或信号量等机制来协调进程对共享资源的访问。</p>
<p>D不正确。进程数越多，由于竞争CPU的资源，实际上可能降低CPU利用率。</p>
<p>本题选D。</p>
</li>
</ul>
<h2 id="13-操作系统运行环境">1.3 操作系统运行环境<a hidden class="anchor" aria-hidden="true" href="#13-操作系统运行环境">#</a></h2>
<p>CPU的特权级</p>
<ul>
<li>特权级是CPU的硬件特征，分为用户态和内核态，用户程序运行在用户态，操作系统运行在内核态；</li>
<li>代码和数据也具备特权级，只有CPU此时的特权级高于想要访问的代码或数据的特权级时才能访问。</li>
</ul>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1748587553569-9f39eb04-7928-4fbc-83b5-2ba131b9d59e-373789.png" alt=""></p>
<p>内核空间：操作系统程序和数据占用的内存空间，只有内核态下才可以访问；</p>
<p>用户空间：用户代码所占用的内存空间，用户态下可以访问；</p>
<p>当CPU想要访问内存时，会进行特权级检查，只有当CPU特权级高于被访问数据的特权级时才能访问。</p>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1748587922373-0222f261-5385-4206-a510-5edfe4408299-801164.png" alt=""></p>
<h3 id="131-操作系统运行机制">1.3.1 操作系统运行机制<a hidden class="anchor" aria-hidden="true" href="#131-操作系统运行机制">#</a></h3>
<p><strong>应用程序</strong>运行在<strong>用户态</strong>（目态）下，<strong>只能执行非特权指令</strong>。</p>
<p><strong>内核程序</strong>运行在<strong>内核态</strong>（管态）下，是操作系统最重要最核心的部分，也是最接近硬件的部分。</p>
<blockquote>
<p>内核是计算机配置的底层软件，它管理着系统的各种资源，大多数内核包含着以下四方面内容：</p>
<ul>
<li><strong>时钟管理</strong>：提供系统时间、进程切换、时间片、分时操作、作业运行程度衡量、时钟中断等等（读时钟不算）</li>
<li><strong>中断机制</strong>：<strong>负责保护和恢复中断现场的信息，转移控制权到相关的处理程序</strong></li>
<li><strong>原语</strong>：操作系统最底层，最接近硬件；原子性：只能一次性完成，不可中断（通过关闭中断实现）；运行时间短，调用频繁</li>
<li><strong>系统控制的数据结构及处理</strong>：例如：作业控制块、进程控制块 PCB、文件控制块、设备控制块、各链表、消息队列、缓冲区、内存分配表等等的一些基本操作</li>
</ul>
</blockquote>
<ul>
<li>
<p>补充：内核数据结构</p>
<p>操作系统的内核是其最核心的部分，负责管理系统资源和简化硬件与应用程序之间的交互。内核的数据结构对于其性能和功能至关重要，不同的操作系统可能有不同的实现方式和优化策略。以下是一些常见的内核数据结构：</p>
<ol>
<li><strong>进程控制块（PCB，Process Control Block）</strong>：
<ul>
<li>这是最关键的数据结构之一，用于存储关于系统中每个进程的信息。它包括进程状态、进程编号（PID）、程序计数器、寄存器集的状态、内存管理信息（如页表）、账户信息、I/O状态信息（如分配给进程的文件描述符）、以及执行统计。</li>
</ul>
</li>
<li><strong>文件描述符表</strong>：
<ul>
<li>用于管理打开文件的引用。每个进程通常都有一个文件描述符表，表中的每个条目指向一个文件表，其中包含文件的位置、读写位置和访问权限。</li>
</ul>
</li>
<li><strong>内存管理结构</strong>：
<ul>
<li><strong>页表</strong>：映射虚拟地址到物理地址的数据结构。</li>
<li><strong>段表</strong>：在基于段的内存管理中使用，用来映射线性地址空间到物理内存。</li>
<li><strong>伙伴系统（Buddy System）</strong>：用于内存分配的数据结构，支持动态内存分配与释放。</li>
<li><strong>空闲内存列表或位图</strong>：跟踪可用物理内存的数据结构。</li>
</ul>
</li>
<li><strong>调度队列</strong>：
<ul>
<li>管理就绪进程的队列，通常包括多个不同优先级的队列。</li>
<li><strong>等待队列</strong>：用于等待特定资源或事件的进程列表。</li>
</ul>
</li>
<li><strong>中断向量表</strong>：
<ul>
<li>一个数组，存储中断服务例程（ISR）的地址。当发生中断时，CPU会使用这个表来确定应当调用哪个服务例程。</li>
</ul>
</li>
<li><strong>同步原语的数据结构</strong>：
<ul>
<li><strong>信号量</strong>、<strong>互斥锁（Mutex）<strong>和</strong>条件变量</strong>等，用于进程或线程间的同步。</li>
</ul>
</li>
<li><strong>设备驱动表</strong>：
<ul>
<li>包含系统中所有设备的驱动程序的指针和状态信息。</li>
</ul>
</li>
<li><strong>缓冲区和缓存管理</strong>：
<ul>
<li>用于文件系统和I/O系统，比如缓冲区高速缓存和页缓存。</li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>【注】：</p>
<ul>
<li>用户态不能执行特权指令（只有内核程序才能执行），<strong>内核态除了访管指令外，可执行一切指令</strong>；</li>
<li>**必须在内核态的操作指令：**与<em>I/O</em>、置时钟、置中断、内存保护寄存器、程序状态寄存器等相关的指令</li>
<li>CPU 中有一个寄存器叫<strong>程序状态字寄存器（<code>PSW</code>）</strong>，其中有个二进制位，1表示&quot;内核态&quot;，0表示&quot;用户态&quot;</li>
<li>常见的事件如<strong>系统调用、外部中断和缺页</strong>等都是<strong>发生</strong>在用户态的，<strong>进程切换和缺页处理等只能发生在内核态</strong>；常见的指令如陷阱指令、跳转指令、数据传送指令和设置断点指令等都在用户态执行，<strong>所有特权指令如关中断指令、I/O 指令等只能在内核态执行。</strong></li>
</ul>
</blockquote>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1745170793415-aa7ff9f5-55bd-4be7-a177-ca64c2ccbe20-963203.png" alt=""></p>
<p><strong>多重中断机制下的寄存器保存</strong>：在多重中断环境中，由于中断可能在用户态或内核态下响应，因此PSW寄存器必须保存（其中的特权标志位指示当前响应中断的进程状态）。而普通子程序或函数调用不涉及特权级切换，全程在用户态执行，故无需保存PSW。</p>
<hr>
<p>用户栈与内核栈</p>
<p><strong>用户栈</strong>（低特权级）：支持用户空间程序执行</p>
<ul>
<li>管理函数调用的局部变量、参数和返回地址</li>
<li>处理用户程序中的函数调用和返回逻辑</li>
<li>仅限用户态访问，无法直接操作内核资源</li>
</ul>
<p><strong>内核栈</strong>（高特权级）：支持内核代码执行</p>
<ul>
<li>当进程通过系统调用、中断或异常进入内核态时，硬件自动切换到内核栈</li>
<li>存储内核函数调用链、临时变量及执行上下文</li>
<li>确保内核代码安全执行，防止用户态数据污染内核空间</li>
</ul>
<hr>
<p><strong>进程独立内核栈的必要性</strong></p>
<p>所有进程在运行时都可能通过系统调用陷入内核态继续执行。假设进程A陷入内核执行时需等待资源，主动调用<code>schedule()</code>让出CPU，而进程B随后也通过系统调用进入内核态，若共享内核栈，则进程B的系统调用压栈操作将破坏进程A的栈数据，导致系统不稳定。</p>
<h3 id="该考点真题">该考点真题<a hidden class="anchor" aria-hidden="true" href="#该考点真题">#</a></h3>
<p>【2011-24】下列选项中，在用户态执行的是（ ）。</p>
<p>A. 命令解释程序</p>
<p>C. 进程调度程序</p>
<p>B. 缺页处理程序</p>
<p>D. 时钟中断处理程序</p>
<ul>
<li>
<p>答案</p>
<p>A正确。命令解释程序 (Command Interpreter) 是运行在用户态的应用程序，也称为shell。它接收用户输入的命令，并将其解释和执行。命令解释程序负责解析命令行参数、调用相应的系统调用和应用程序来执行命令，以及显示结果给用户。</p>
<p>B、C、D错误。进程调度程序、缺页处理程序和时钟中断处理程序通常是在内核态（也称为特权态）下执行的。这些程序涉及到底层的操作系统功能，需要更高的权限才能执行。</p>
<p>本题选A。</p>
</li>
</ul>
<p>【2012-23】下列选项中，不可能在用户态发生的事件是（ ）。</p>
<p>A. 系统调用</p>
<p>B. 外部中断</p>
<p>C. 进程切换</p>
<p>D. 缺页</p>
<ul>
<li>
<p>答案</p>
<p><strong>本题考察“在用户态发生”，而非“在用户态执行”。</strong></p>
<p>A错误。系统调用是由用户态程序主动发起的请求，用于请求操作系统提供特权操作或资源访问权限.</p>
<p>B错误。外部中断是由外部设备或事件触发的中断请求，可能发生在用户态。外部中断通常在内核态进行处理。</p>
<p>C正确。进程切换是操作系统调度器根据调度策略从一个运行的进程切换到另一个进程的操作。用户态程序是无法直接调用进程切换的，程序只能通过系统调用接口向操作系统发送某些请求，如fork、exec、yield等，然后由操作系统内核在内核态中处理这些请求，处理请求的过程中可能需要进行进程切换。进程切换涉及到修改和管理进程的上下文信息，包括保存和恢复寄存器状态、切换页表等操作。</p>
<p>D错误。缺页指的是程序访问的内存页不在物理内存中，需要通过页表映射和磁盘交换等机制从磁盘加载到内存中才能继续执行。当用户态程序访问一个缺页时，处理器会触发缺页异常，并由操作系统在内核态进行缺页处理。</p>
<p>本题选C。</p>
</li>
</ul>
<p>【2013-28】下列选项中，会导致用户进程从用户态切换到内核态的操作是（ ）。</p>
<p>I. 整数除以零</p>
<ol>
<li>sin() 函数调用</li>
<li>read 系统调用</li>
</ol>
<p>A. 仅 I、II</p>
<p>B. 仅 I、III</p>
<p>C. 仅 II、III</p>
<p>D. I、II 和 III</p>
<ul>
<li>
<p><strong>答案</strong></p>
<p>I正确。整数除以零导致异常。该异常会导致处理器从用户态切换到内核态，以便内核能够处理异常情况。</p>
<p>II错误。调用数学库函数如 sin() 不会导致用户进程切换到内核态。这样的函数调用仅在用户态执行，然后返回结果给用户进程。</p>
<p>III正确。read 系统调用用于从文件描述符读取数据。当用户进程调用 read 系统调用时，它必须切换到内核态，以便内核可以执行读取文件的操作。这涉及到访问和操作内核数据结构，因此用户进程会从用户态切换到内核态。</p>
<p>综上，I和III正确。</p>
<p>本题选B。</p>
</li>
</ul>
<hr>
<p>【2014-25】下列指令中，不能在用户态执行的是（ ）。</p>
<p>A. trap指令</p>
<p>B. 跳转指令</p>
<p>C. 压栈指令</p>
<p>D. 关中断指令</p>
<ul>
<li>
<p>答案</p>
<p>在用户态执行的指令是受限制的，通常只能执行非特权操作。</p>
<p>A错误。trap指令即陷阱指令，用户在发起系统调用时，在执行完传送指令将参数传送至寄存器后，便会执行trap指令陷入内核态。</p>
<p>B错误。跳转指令用于在程序中无条件或有条件地跳转到指定的地址。跳转指令通常是用户态程序的一部分，因此可以在用户态执行。</p>
<p>C错误。压栈指令是将数据压入栈中的指令，用于保存当前执行环境和数据。在用户态程序中，可以使用压栈指令来维护局部变量、函数调用的返回地址等，因此可以在用户态执行。</p>
<p>D正确。关中断指令用于在处理器中禁用中断请求。这个指令是一种特权操作，只有处于内核态（特权态）的代码才能执行。用户态程序没有权限执行关中断指令。</p>
<p>本题选D。</p>
</li>
</ul>
<p>【2015-24】假定下列指令已装入指令寄存器，则执行时不可能导致CPU从用户态变为内核态（系统态）的是（ ）。</p>
<p>A. DIV R0, R1 ；(R0) / (R1) → R0</p>
<p>B. INT n ；产生软中断</p>
<p>C. NOT R0 ；寄存器R0的内容取非</p>
<p>D. MOV R0, addr ；把地址addr处的内存数据放入寄存器R0中</p>
<ul>
<li>
<p>答案</p>
<p>A错误。指令 DIV R0, R1 执行的是除法操作，若除数(R1)为0，则产生异常，需要操作系统在内核态进行处理，会导致CPU从用户态变为内核态。</p>
<p>B错误。指令 INT n 产生软中断，会触发相应的的中断处理程序，需要操作系统在内核态进行处理，会导致CPU从用户态变为内核态。</p>
<p>C正确。指令 NOT R0 为将寄存器R0的内容取非，这是一个简单的逻辑操作，位运算即可实现，只需要在用户态进行处理，不可能导致CPU从用户态变为内核态。</p>
<p>D错误。指令 MOV R0, addr 将内存数据加载到寄存器中。虚拟地址空间包括内核与用户空间。其中内核空间供内核使用，用户空间供用户程序使用。在用户态下，应用程序无法直接访问内核空间的内存。如果 addr 所指向的内存地址是用户空间的地址，那么执行 MOV R0, addr 是在用户态进行的，不会导致 CPU 从用户态变为内核态。然而，如果 addr 所指向的内存地址是内核空间的地址，或者是特定的内存映射区域（例如 I/O 地址空间），那么执行 MOV R0, addr 可能需要切换到内核态。在这种情况下，操作系统需要处理这个指令，将 addr 所指向的数据加载到 R0 寄存器中，因此 CPU 可能会切换到内核态执行指令，并在内核态下访问内核空间的内存。</p>
<p>本题选C。</p>
</li>
</ul>
<p>【2021-23】下列指令中，只能在内核态执行的是（ ）。</p>
<p>A. trap指令</p>
<p>B. I/O指令</p>
<p>C. 数据传送指令</p>
<p>D. 设置断点指令</p>
<ul>
<li>
<p>答案</p>
<p>A错误。</p>
<p>B正确。I/O指令（输入/输出指令）是用于进行输入和输出操作的指令。I/O指令只能在内核态下执行。</p>
<p>C错误。数据传送指令可以在用户态执行。例如将数据从内存复制到寄存器或寄存器之间的传送。</p>
<p>D错误。设置断点指令可以在用户态执行。例如在调试过程中，用户程序可以设置断点指令来中断程序执行并进行调试操作。</p>
<p>本题选B。</p>
</li>
</ul>
<p>【2022-27】下列关于CPU模式的叙述中，正确的是（ ）。</p>
<p>A. CPU处于用户态时只能执行特权指令</p>
<p>B. CPU处于内核态时只能执行特权指令</p>
<p>C. CPU处于用户态时只能执行非特权指令</p>
<p>D. CPU处于内核态时只能执行非特权指令</p>
<ul>
<li>
<p>答案</p>
<p>CPU处于用户态时只能执行非特权指令。CPU处于内核态时即能执行非特权指令也能特权指令。</p>
<p>本题选C。</p>
</li>
</ul>
<p>【2023-24】在操作系统内核中，中断向量表适合采用的数据结构是（ ）。</p>
<p>A. 数组</p>
<p>B. 队列</p>
<p>C. 单向链表</p>
<p>D. 双向链表</p>
<ul>
<li>
<p>答案</p>
<p>
  <img src="https://cdn.nlark.com/yuque/0/2025/png/42876865/1745222902539-75fcc77d-5cb6-4fce-8227-f4ad4e0ca6df.png" alt=""></p>
<p>中断向量表是用于存储中断处理程序入口地址的数据结构。中断向量表的索引对应着中断类型号或中断向量号，而其中存储的值是对应中断类型的处理程序的入口地址。</p>
<p>使用数组作为中断向量表的数据结构有以下几个优点：</p>
<p>①快速访问：数组通过索引可以直接定位到对应位置的中断处理程序入口地址，具有常量时间复杂度的访问性能。这是因为中断类型号或中断向量号是连续的整数，可以通过简单的计算得到对应的数组下标。</p>
<p>②紧凑存储：由于中断类型号或中断向量号是连续的整数，使用数组可以直接按照顺序将中断处理程序的入口地址存储在连续的内存空间中，这样可以节省内存空间。</p>
<p>因此，中断向量表适合采用数组作为数据结构。</p>
<p>四个选项中也只有选项A支持随机访问。</p>
<p>本题选A。</p>
</li>
</ul>
<p>【2023-26】下列操作完成时，导致CPU从内核态转为用户态的是（ ）。</p>
<p>A. 阻塞进程</p>
<p>B. 执行 CPU 调度</p>
<p>C. 唤醒进程</p>
<p>D. 执行系统调用</p>
<ul>
<li>
<p><strong>答案</strong></p>
<p>A错误。阻塞进程发起时，CPU会由用户态转为内核态，保存当前阻塞进程的上下文到它的PCB里面，然后将该进程的pcb挂到阻塞队列里，至此阻塞完成，CPU还是处于内核态之中，之后调度程序从就绪队列选择一个进程上处理机，进程切换完成之后，才会返回用户态，因此A错误。</p>
<p>B错误。执行 CPU 调度完成时，还是处于内核态，具体见进程切换那边的详解。</p>
<p>C错误。在操作系统中，当一个进程发起某种需要等待的操作（如等待I/O操作完成或等待某个信号），它会被标记为睡眠状态，然后被放入等待队列中。当满足等待条件时，操作系统会将进程从等待队列中唤醒，使其重新变为可执行状态。</p>
<p>D正确。当CPU执行的系统调用完成时，会触发从内核态转换到用户态。在执行系统调用期间，CPU首先会从用户态切换到内核态，然后操作系统执行相应的操作，最后该操作完成时，CPU将再次切换回用户态。系统调用结束后，CPU可以继续执行用户程序。</p>
<p>本题选D。</p>
</li>
</ul>
<hr>
<h3 id="132-系统调用">1.3.2 系统调用<a hidden class="anchor" aria-hidden="true" href="#132-系统调用">#</a></h3>
<p><strong>系统调用</strong>（system call）：应用程序<strong>主动</strong>向操作系统发出的服务请求</p>
<p><strong>异常</strong>（exception)：非法指令或者其他原因导致当前指令执行失败（如：内存出错）后的处理请求</p>
<p><strong>中断</strong>(hardware interrupt)：来自硬件设备的处理请求</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th>中断</th>
          <th>异常</th>
          <th>系统调用</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>源头</td>
          <td>外设</td>
          <td>应用程序意想不到的行为</td>
          <td>应用程序请求操作系统提供服务</td>
      </tr>
      <tr>
          <td>响应方式</td>
          <td>异步</td>
          <td>同步</td>
          <td>异步或同步</td>
      </tr>
      <tr>
          <td>处理机制</td>
          <td>持续，对用户应用程序透明</td>
          <td>杀死进程或者重新执行等</td>
          <td>等待和持续</td>
      </tr>
  </tbody>
</table>
<ul>
<li>在这个表格中，&ldquo;响应方式&quot;指的是触发事件与处理事件之间的时间关系：
<ul>
<li><strong>异步响应</strong>：指中断发生的时间与CPU的指令流无关，是在CPU执行指令的&quot;任意时刻&quot;发生的。外设产生的中断是异步的，因为它们可以在CPU执行任何指令期间随时发生。</li>
<li><strong>同步响应</strong>：指事件的发生与CPU的指令执行有直接关系，通常是由当前指令执行引起的。异常是同步的，因为它们总是与特定指令的执行直接相关。</li>
<li><strong>系统调用</strong>可以是同步的也可以是异步的，这取决于具体的系统调用类型和实现方式。一些系统调用会立即返回结果（同步），而另一些可能会让进程等待直到某个条件满足（异步）。</li>
</ul>
</li>
</ul>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1745172528163-11dd156e-6b30-4d47-8e52-8db7d68cc488-311030.png" alt=""></p>
<hr>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1745153934393-d3b28f48-a448-4d6c-9b19-7583af124c86-384133.png" alt=""></p>
<ol>
<li>
<p>什么是系统调用，有什么用？</p>
<p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。</p>
 <aside>
 💡
<p>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务。</p>
 </aside>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1745127436808-4b4b5b66-664e-4b5b-889c-ba77306265dc-999288.png" alt=""></p>
</li>
<li>
<p>系统调用与库函数的区别：</p>
<table>
  <thead>
      <tr>
          <th>普通应用程序</th>
          <th>可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>编程语言</td>
          <td>向上提供<strong>库函数</strong>。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。</td>
      </tr>
      <tr>
          <td>操作系统</td>
          <td>向上提供系统调用，使得上层程序能请求</td>
      </tr>
      <tr>
          <td>裸机</td>
          <td></td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>系统调用按照功能分类：应用程序通过<strong>系统调用</strong>请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是<strong>与共享资源有关的操作</strong>（<strong>如存储分配、I/O操作、文件管理等</strong>），都必须通过系统调用的方式向<strong>操作系统内核</strong>提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p>
</li>
</ol>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100961713-6a8bff3a-d3c2-466b-b378-9cdc7a9ea13d-467070.png" alt=""></p>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1709090177640-e73812bf-8f99-4bab-8a34-3bad076790c8-285206.png" alt=""></p>
<ol>
<li>
<p>系统调用的过程：<strong>传递系统调用参数→执行陷入指令（用户态）→执行相应的内核请求程序处理系统调用（核心态）→返回应用程序</strong></p>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100961717-3a410d31-2f9e-41b4-86d9-577c85c2269a-953259.png" alt=""></p>
</li>
</ol>
<p><strong>详细版：</strong></p>
<p><figure>
    <img src="/posts/blog/%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image_hu_656e7a7ec8bacfe.png" 
         alt="" 
         title="">
  </figure></p>
<p>注意：</p>
<ul>
<li>
<p>**注意区分系统调用号和中断类型号，**前者用于标识当前系统调用的类型，后者用于标识当前中断或异常的类型。</p>
</li>
<li>
<p><strong>陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态</strong></p>
</li>
<li>
<p>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</p>
</li>
<li>
<p><strong>陷入指令 = trap 指令 = 访管指令 = 自陷指令 = 陷阱指令</strong></p>
</li>
<li>
<p>陷入指令引发的异常又称为访管中断</p>
</li>
<li>
<p>自陷指令触发异常时保存的断点为下一条指令的地址（若还是该指令的地址，则会陷入死循环）</p>
</li>
<li>
<p><strong>额外补充：IA-32+Linux的系统调用：袁《计算机系统基础》</strong></p>
<p><strong>系统调用是一种特殊的“异常事件</strong>”，是操作系统为用户程序提供服务的一种手段。Linux提供了几百种系统调用，<strong>主要分为以下几类：进程控制、文件操作、文件系统操作、系统控制、内存管理、网络管理、用户管理和进程通信。系统调用号用整数表示，它用来确定系统调用跳转表中的偏移量</strong>。跳转表中每个表项给出相应系统调用对应的<strong>系统调用服务例程</strong>的首地址。表7.3给出了部分Linux 系统调用的调用号、名称及其含义。</p>
<p>
  <img src="https://typora-darkmoon.oss-cn-nanjing.aliyuncs.com/5A0AF5A002E629012660BA6786C97A11.png" alt=""></p>
<p>内核实现的<strong>系统调用</strong>是以一个<strong>软中断的形式（即陷阱指令）<strong>来提供的，如果高级语言编写的用户程序直接用陷阱指令来调用系统调用，则会很麻烦，因此，需要将系统调用</strong>封装成用户程序能直接调用的函数</strong>，如<code>exit()</code>、<code>read()</code>和<code>open()</code>，这些都是<strong>标准C库中系统调用对应的封装函数</strong>。在用C语言编写的用户程序中，只要用<code>#include</code>命令嵌入相应的头文件，就可以直接使用这些函数来调出操作系统内核中相应的系统调用服务例程，以完成与I/O、文件操作以及进程管理等相关的操作。在本书中将系统调用及对应的封装函数称为<strong>系统级函数</strong>。</p>
<p>从C语言编程者角度来看，系统级函数在形式上与普通的应用编程接口（<code>API</code>）以及普通的C语言函数没有差别。但是，实际上它们在机器级代码的具体实现上是不同的。例如，在<code>IA-32+Linux</code>中，**普通函数（包括<code>API</code>）使用<code>CALL</code>指令来实现过程调用，而系统调用则使用陷阱指令来实现。**对于过程调用，执行<code>CALL</code>指令前后，处理器一直在用户态下执行指令，因而，所执行的指令是受限的，所能访问的存储空间也是受限的；而对于系统调用，一旦执行了发出系统调用的陷阱指令，处理器就从用户态转到内核态下运行，此时，CPU可以执行特权指令并访问内核空间。</p>
<p>实现普通的<code>API</code>以及普通的库函数可能会使用一个或多个系统调用服务功能，也可能不需要使用系统调用服务功能，例如，对于数学库函数，就无须使用系统调用服务功能。**在Linux系统中，系统调用所用的参数通过寄存器传递，而不是像过程调用那样用栈来传递，因此，在封装函数对应的机器级代码中，将使用<code>传送指令</code>把系统调用所需要的参数传送到相应的寄存器。**按照惯例，系统调用号存放在EAX中，传递参数的寄存器顺序依次为：EAX（调用号）、EBX、ECX、EDX、ESI、EDI和EBP，除调用号以外，最多6个参数。若参数个数超出寄存器个数，则将参数块所在存储区的首址放在寄存器中传递。</p>
<p><strong>封装函数对应的机器级代码有一个统一的结构：总是若干条传送指令后跟上一条陷阱指令</strong>。<strong>传送指令用来传递系统调用所用的参数，陷阱指令用来陷入内核进行处理</strong>。例如，若用户程序希望将字符串<code>“hello，world！”</code>中的14个字符显示在标准输出设备文件<code>stdout</code>上，则可以调用系统调用<code>write(1，“hello，world!”，14）</code>，它的封装函数用以下机器级代码（用汇编指令表示）实现。</p>
<p><figure>
    <img src="/posts/blog/%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/1745172996423_hu_5451605307646ece.jpg" 
         alt="" 
         title="">
  </figure></p>
<p>在Linux中，有一个系统调用的统一入口，即是系统调用处理程序<code>system_call</code>的首地址，所以，<strong>CPU执行指令<code>int$0x80</code>后，便转到<code>system_call</code>的第一条指令开始执行。在<code>system_call</code>中，将根据调用号跳转到当前系统调用对应的系统调用服务例程去执行</strong>。<code>system_call</code>执行完后返回到<code>int $0x80</code>指令后面一条指令继续执行。返回参数在<code>EAX</code>中，为整数值，若是正数或0表示成功，负数表示出错码。</p>
<ol start="2">
<li><strong>每个系统调用的封装函数都会被转换为一组与具体机器架构相关的指令序列，这个指令序列中至少有一条陷阱指令</strong>，在陷阱指令之前可能还有若干条传送指令用于将I/O操作的参数送入相应的寄存器。</li>
</ol>
<p>例如，在IA-32中，陷阱指令就是<code>INTn</code>指令，也称为<strong>软中断</strong>指令。在早期IA-32架构中，Linux 系统将<code>int $Ox80</code>指令用作系统调用，<strong>在系统调用指令之前会有一串传送指令，用来将系统调用号等参数传送到相应的寄存器</strong>。系统调用号通常在EAX寄存器中，内核程序可根据系统调用号选择执行一个系统调用服务例程。这样，用户进程的I/O请求通过调出操作系统中相应的系统调用服务例程来实现。</p>
<p><strong>系统调用命令经过编译后，形成若干参数和陷入指令！</strong></p>
<p>
  <img src="https://typora-darkmoon.oss-cn-nanjing.aliyuncs.com/0BFFDF4B25FD726B8FA4739F328DE56B.png" alt=""></p>
<p>
  <img src="https://typora-darkmoon.oss-cn-nanjing.aliyuncs.com/4481453A7946B67E9D5C3449D0DBAA06.png" alt=""></p>
<hr>
</li>
</ul>
<h2 id="14-操作系统结构">1.4 操作系统结构<a hidden class="anchor" aria-hidden="true" href="#14-操作系统结构">#</a></h2>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100961691-ffcfce0a-6aec-4662-b3ad-a7339aa5e953-875204.png" alt=""></p>
<table>
  <thead>
      <tr>
          <th><strong>结构</strong></th>
          <th><strong>特性与思想</strong></th>
          <th><strong>优点</strong></th>
          <th><strong>缺点</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>分层结构</td>
          <td>内核分多层，每层可调用且仅可调用更低一层提供的接口</td>
          <td>1. 便于调试和验证，自底向上逐层调试验证</td>
          <td></td>
      </tr>
      <tr>
          <td>2.易扩展、易维护，各层之间调用接口明确固定</td>
          <td>1. 只能调用相邻低层，难以合理定义各层边界</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>2.效率低，跨层调用受限，系统调用执行时间长</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>模块化</td>
          <td>将内核划分为多个模块，各模块之间通过已定义接口交互；主模块仅保留内核核心功能，可加载内核模块可按需动态装载与卸载</td>
          <td>1. 接口清晰，模块可并行开发2.易于维护与扩展，可裁剪性强</td>
          <td></td>
      </tr>
      <tr>
          <td>3.灵活性高</td>
          <td>1. 模块间接口定义与实现较难</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>2. 模块间可能产生依赖，联调与验证更复杂</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>宏内核（大内核）</td>
          <td>操作系统的大部分功能都放在内核态，常配合&quot;模块化&quot;设计思想</td>
          <td>1.性能高，内核内各功能可直接相互调用</td>
          <td></td>
      </tr>
      <tr>
          <td>2. 共享地址空间，调用开销小、效率高</td>
          <td>1. 内核庞大复杂，维护困难</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>2. 某模块出错可能导致整个系统崩溃</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>微内核</td>
          <td>仅保留最基本功能在内核态（如中断与陷入处理、进程/线程管理与调度、基础内存机制、进程间通信），其余功能移到用户态由服务器提供，客户端通过消息传递请求服务</td>
          <td>1. 内核小、可靠性高，出错隔离好</td>
          <td></td>
      </tr>
      <tr>
          <td>2.扩展性与可移植性好，便于支持分布式</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>3.安全性强</td>
          <td>1.性能较差，频繁的用户态/内核态切换与消息传递开销大</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>2. 用户态模块间不能直接调用，必须经由内核转发</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>外核（exokernel）</td>
          <td>尽量减少抽象层，内核负责资源分配与保护，允许应用直接管理底层硬件资源；应用通常配合库操作系统构建所需抽象</td>
          <td>1. 抽象层更薄，减少重映射与中间层开销，效率高</td>
          <td></td>
      </tr>
      <tr>
          <td>2. 允许应用自定义抽象，灵活性强</td>
          <td>1. 系统整体复杂度提高</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>2.一致性与通用性降低</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="141-分层法">1.4.1 分层法<a hidden class="anchor" aria-hidden="true" href="#141-分层法">#</a></h3>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100961751-7c97b29c-519a-444d-addb-12badac57ae1-619643.png" alt=""></p>
<p><strong>分层法是将操作系统分为若干层，最底层（层0）为硬件，最高层（层N）为用户接口，每层只能调用紧邻它的低层的功能和服务（单向依赖）</strong>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">printf</span><span class="p">(){</span>    
</span></span><span class="line"><span class="cl">		<span class="p">...</span>    
</span></span><span class="line"><span class="cl">		<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>    
</span></span><span class="line"><span class="cl">		<span class="nf">write</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>    
</span></span><span class="line"><span class="cl">		<span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>分层法的<strong>优点</strong>：①便于系统的调试和验证，简化了系统的设计和实现。第1层可先调试而无须考虑系统的其他部分，因为它只使用了基本硬件。第1层调试完且验证正确之后，就可以调试第2层，如此向上。如果在调试某层时发现错误，那么错误应在这一层上，这是因为它的低层都调试好了。②易扩充和易维护。在系统中增加、修改或替换一层中的模块或整层时，只要不改变相应层间的接口，就不会影响其他层。</li>
<li>分层法的<strong>问题</strong>：①合理定义各层比较困难。因为依赖关系固定后，往往就显得不够灵活。②效率较差。操作系统每执行一个功能，通常要自上而下地穿越多层，各层之间都有相应的层间通信机制，这无疑增加了额外的开销，导致系统效率降低。</li>
</ul>
<hr>
<h3 id="142-模块化">1.4.2 模块化<a hidden class="anchor" aria-hidden="true" href="#142-模块化">#</a></h3>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100961696-48d117df-87f1-4a09-a58a-f8191544f988-715888.png" alt=""></p>
<p><strong>模块化</strong>是将操作系统按功能划分为若干个具有一定独立性的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能通过接口进行通信。还可以进一步将各模块</p>
<p>细分为若干个具有一定功能的子模块，同样也规定好各子模块之间的接口。把这种设计方法称为<strong>模块-接口法</strong>，如图所示为由模块、子模块等组成的模块化操作系统结构。</p>
<p><strong>模块划分问题：</strong></p>
<ul>
<li>如果将模块划分得<strong>太小</strong>，虽然能降低模块本身的复杂性，但<strong>会使得模块之间的联系过多</strong>，造成系统比较混乱；</li>
<li>如果模块划分得<strong>过大</strong>，又<strong>会增加模块内部的复杂性</strong>，显然应在两者间进行权衡。</li>
</ul>
<p>此外，在划分模块时，要充分考虑模块的<strong>独立性问题</strong>，因为模块独立性越高，各模块间的交互就越少，系统的结构也就越清晰。<strong>衡量模块的独立性主要有两个标准：</strong></p>
<ul>
<li>内聚性，模块内部各部分间联系的紧密程度。<code>内聚性</code><strong>越高，模块独立性越好。</strong></li>
<li>耦合度，模块间相互联系和相互影响的程度。<code>耦合度</code><strong>越低，模块独立性越好。</strong></li>
</ul>
<p>模块化的<strong>优点</strong>：</p>
<ul>
<li>提高了操作系统设计的正确性、可理解性和可维护性；</li>
<li>增强了操作系统的可适应性；</li>
<li>加速了操作系统的开发过程。</li>
</ul>
<p>模块化的<strong>缺点</strong>：</p>
<ul>
<li>模块间的接口规定很难满足对接口的实际需求。</li>
<li>各模块设计者齐头并进，每个决定无法建立在上一个已验证的正确决定的基础上，因此无法找到一个可靠的决定顺序。</li>
</ul>
<hr>
<h3 id="143-宏内核与微内核">1.4.3 宏内核与微内核<a hidden class="anchor" aria-hidden="true" href="#143-宏内核与微内核">#</a></h3>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100961716-37514bd3-3175-4d39-b9cc-445e8ac39411-629281.png" alt=""></p>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100961676-650230d7-8417-4c8a-855e-94c5b3869e6e-253344.png" alt=""></p>
<ol>
<li><strong>宏内核</strong></li>
</ol>
<ul>
<li>
<p>思想：宏内核，也称<strong>单内核</strong>或<strong>大内核</strong>，是指<strong>将系统的主要功能模块都作为一个紧密联系的整体运行在核心态</strong>，从而为用户程序提供高性能的系统服务。目前主流的操作系统，如Windows、Android、iOS、macOS、Linux等，都是基于宏内核的构架。</p>
<blockquote>
<p>目前主流的操作系统早已不是当年纯粹的宏内核构架了，而是广泛吸取微内核构架的优点而后揉合而成的混合内核。</p>
</blockquote>
</li>
<li>
<p><strong>优点</strong>：性能高，内核内部各模块之间信息共享，各种功能都可以直接相互调用，</p>
<blockquote>
<p>与进程都有自己独立的虚拟地址空间不同，内核各程序共享地址空间和各类资源，因此可以很方便地信息共享和相互调用。</p>
</blockquote>
</li>
<li>
<p><strong>缺点</strong>：随着体系结构和应用需求的不断发展，需要操作系统提供的服务越来越复杂，<strong>内核庞大功能复杂，结构混乱，难以维护；大内核中某个功能模块出错，就可能导致整个系统崩溃。</strong></p>
</li>
</ul>
<hr>
<ol>
<li><strong>微内核</strong></li>
</ol>
<blockquote>
<p>基于C/S架构的功能模块化设计的操作系统</p>
</blockquote>
<ul>
<li>
<p><strong>思想</strong>：微内核构架，是指<strong>将内核中最基本的功能保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，从而降低内核的设计复杂性</strong>。那些移出内核的操作系统代码根据<strong>分层</strong>的原则被划分成<strong>若干服务程序</strong>，它们的执行相互独立，交互则都借助于微内核进行通信。</p>
</li>
<li>
<p>微内核结构将操作系统划分为两大部分：<strong>微内核和多个服务器。</strong></p>
<ul>
<li>
<p><strong>微内核</strong>是指精心设计的、能实现操作系统最基本核心功能的小型内核，通常包含：</p>
<ul>
<li>①与硬件处理紧密相关的部分；</li>
<li>②一些较基本的功能；</li>
<li>③客户和服务器之间的通信。</li>
<li>这些部分只是为构建通用操作系统提供一个重要基础，这样就可以确保将内核做得很小。</li>
</ul>
</li>
<li>
<p>操作系统中的<strong>绝大部分功能都放在微内核外的一组服务器（进程）中实现</strong>，如用于提供对进程（线程）进行管理的<strong>进程（线程）服务器</strong>、提供虚拟存储器管理功能的<strong>虚拟存储器服务器</strong>等，它们都是作为进程来实现的，<strong>运行在用户态</strong>，客户与服务器之间是借助微内核提供的<strong>消息传递机制</strong>来实现交互的。下图展示了单机环境下的客户/服务器模式。</p>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100961908-6bac3ef6-f3d2-4189-9adb-54016f5f8580-852553.png" alt=""></p>
</li>
</ul>
</li>
<li>
<p><strong>微内核的基本功能</strong></p>
</li>
</ul>
<p>微内核结构通常利用<code>机制与策略分离</code>的原理来构造OS结构，<strong>将机制部分以及与硬件紧密相关的部分放入微内核</strong>。微内核通常具有如下功能：</p>
<ol>
<li>
<p><strong>进程（线程）管理</strong></p>
<p>进程（线程）之间的通信功能是微内核OS最基本的功能，此外还有<strong>进程的切换、进程的调度，以及多处理机之间的同步</strong>等功能，都应<strong>放入微内核中</strong>。举个例子，为实现进程调度功能，需要在进程管理中设置一个或多个进程优先级队列，这部分属于调度功能的<code>机制部分</code>，应将它放入微内核中。而<strong>对用户进程如何分类，以及优先级的确认方式，则属于</strong><code>策略问题</code><strong>，可将它们放入微内核外的进程管理服务器中。</strong></p>
</li>
<li>
<p><strong>低级存储器管理</strong></p>
<p>在微内核中，只配置最基本的低级存储器管理机制，如用于实现将逻辑地址变换为物理地址等的<strong>页表机制和地址变换机制，这一部分是依赖于硬件的，因此放入微内核</strong>。而实现虚拟存储器管理的策略，则包含<strong>应采取何种页面置换算法，采用何种内存分配与回收的</strong><code>策略</code>，应将这部分放在微内核外的存储器管理服务器中。</p>
</li>
<li>
<p><strong>中断和陷入处理</strong></p>
<p>微内核OS将与硬件紧密相关的一小部分放入微内核，此时微内核的主要功能是捕获所发生的中断和陷入事件，并进行中断响应处理，在识别中断或陷入的事件后，再发送给相关的服务器来处理，<strong>故中断和陷入处理也应放入微内核</strong>。</p>
</li>
</ol>
<p>微内核操作系统将进程管理、存储器管理以及I/O管理这些功能一分为二，**属于机制的很小一部分放入微内核，而绝大部分放入微内核外的各种服务器实现，**大多数服务器都要比微内核大。因此，在采用客户/服务器模式时，能把微内核做得很小。</p>
<ul>
<li>优点：
<ul>
<li><strong>扩展性和灵活性</strong>：许多功能从内核中分离出来，当要修改某些功能或增加新功能时，只需在相应的服务器中修改或新增功能，或再增加一个专用的服务器，而无须改动内核代码（内核小功能少，易于维护，内核可靠性高）</li>
<li><strong>可靠性和安全性</strong>：只有微内核运行在内核态，其余模块都运行在用户态，**一个模块中的错误只会使这个模块崩溃，而不会使整个系统崩溃。**例如，文件服务代码运行时出了问题，宏内核因为文件服务是运行在内核态的，系统直接就崩溃了。而微内核的文件服务是运行在用户态的，只要把文件服务功能强行停止，然后重启，就可以继续使用，系统不会崩溃。</li>
<li>可移植性：与CPU和I/O硬件有关的代码均放在内核中，而其他各种服务器均与硬件平台无关，因而将操作系统移植到另一个平台上所需做的修改是比较小的。</li>
<li>分布式计算。客户和服务器之间、服务器和服务器之间的通信采用消息传递机制，这就使得微内核系统能很好地支持分布式系统和网络系统。</li>
</ul>
</li>
<li>缺点：
<ul>
<li><strong>性能差</strong>：因为需要<strong>频繁地在核心态和用户态之间进行切换，操作系统的执行开销偏大</strong>。为了改善运行效率，可以将那些频繁使用的系统服务移回内核，从而保证系统性能，但这又会使微内核的容量明显地增大。</li>
<li><strong>用户态下的各功能模块不能直接相互调用，只有通过内核中的&quot;消息传递&quot;来间接通信，性能也因此降低。</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>虽然宏内核在桌面操作系统中取得了绝对的胜利，但是微内核在实时、工业、航空及军事应用中特别流行，这些领域都是关键任务，需要有高度的可靠性。</p>
</blockquote>
<hr>
<h3 id="145-外核">1.4.5 外核<a hidden class="anchor" aria-hidden="true" href="#145-外核">#</a></h3>
<ul>
<li><strong>设计思路</strong>：尽可能减少抽象层次，<strong>允许应用程序直接访问硬件</strong>，而<code>ExoKernel</code>只负责保护和分配系统资源。应用程序过来请求资源，<code>Exokernel</code>看看资源是否空闲，如果空闲，直接交给应用，至于应用怎么访问是它自己的事。<code>ExoKernel</code>分离了对硬件的使用和保护，使得应用程序可以直接使用没有经过<code>Kernel</code>抽象的硬件，就很好很强大。</li>
</ul>
<blockquote>
<p>《现代操作系统》：与虚拟机克隆真实机器不同，在这种策略下，是对机器进行分区，换句话说，给每个用户整个资源的一个子集。这样，某个虚拟机可能得到磁盘的0至1023盘块，而另一台虚拟机会得到1024至2047盘块，等等。在底层中，一种称为外核（exokernel）的程序在内核态运行。它的任务是为虚拟机分配资源，并检查使用这些资源的企图，以确保没有机器会使用他人的资源。每个用户层的虚拟机可以运行自己的操作系统，如VM/370和Pentium虚拟8086等，但限制只能使用已经申请并且获得分配的那部分资源。</p>
</blockquote>
<ul>
<li><strong>外核机制的优点是</strong>，它减少了映像层。在其他的设计中，每个虚拟机都认为它有自己的磁盘，其盘块号从0到最大编号，这样虚拟机监控程序必须维护一张表格以重映像磁盘地址（以及其他资源）。有了外核，这个重映像处理就不需要了。<strong>外核只需要记录已经分配给各个虚拟机的有关资源即可。<strong>这个方法还有一个优点，它将多道程序（在外核内）与用户操作系统代码（在用户空间内）加以分离，而且相应负载并不重，这是因为</strong>外核所做的只是保持多个虚拟机彼此不发生冲突。</strong></li>
</ul>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100962316-bfd7e162-920c-4670-b87e-ad6517cd281f-256682.png" alt=""></p>
<ul>
<li>
<p>一些误解澄清</p>
<p>“外核是极薄的内核：仅负责资源保护与分配，并将抽象与策略下放到用户态的库操作系统；它仍运行在内核态的软件层，而非专用硬件。”</p>
</li>
</ul>
<hr>
<h2 id="15-操作系统引导">1.5 操作系统引导<a hidden class="anchor" aria-hidden="true" href="#15-操作系统引导">#</a></h2>
<blockquote>
<p>推荐阅读：</p>
<ul>
<li>下面主要引用自 <a href="http://www.ruanyifeng.com/">阮一峰</a><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的？</a></li>
<li><a href="https://www.bilibili.com/video/BV1gb421h7C4/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=defcad5f62788968e79a5f75e0aca2f3">你知道那个帮你叫醒主机的BIOS，究竟是怎么发展而来的吗【BIOS发展史】</a></li>
<li>可以看一下b站的这个视频：<a href="https://www.bilibili.com/video/BV1iA411V7Di/?spm_id_from=333.999.0.0&amp;vd_source=defcad5f62788968e79a5f75e0aca2f3">2.了解计算机的启动过程和主引导扇区，让你的计算机从这里起飞吧</a></li>
<li><a href="https://www.peterjxl.com/ComputerOS/boot/#%E6%89%93%E5%BC%80%E7%94%B5%E6%BA%90%E4%B9%8B%E5%90%8E">从开机到引导操作系统的详细过程包含Linux代码详解</a></li>
<li>清华大学<a href="https://www.bilibili.com/video/BV1uW411f72n?p=11&amp;vd_source=defcad5f62788968e79a5f75e0aca2f3">操作系统的启动</a></li>
<li>维基百科<a href="https://zh.wikipedia.org/wiki/BIOS#%E7%B3%BB%E7%B5%B1%E5%95%9F%E5%8B%95">BIOS</a>、<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95">主引导记录MBR</a>、<a href="https://zh.wikipedia.org/wiki/%E5%95%9F%E5%8B%95%E7%A8%8B%E5%BC%8F">引导程序</a></li>
</ul>
</blockquote>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100962270-0a5acb13-7b93-47dc-a11a-f7dad44b0282-428617.png" alt=""></p>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100962356-0cf44c58-0b6e-43da-bfaa-29299141f513-141121.png" alt=""></p>
<blockquote>
<p>boot的含义：先问一个问题，“启动”用英语怎么说？</p>
<p>回答是boot。可是，boot原来的意思是靴子，“启动”与靴子有什么关系呢？ 原来，这里的boot是bootstrap（鞋带）的缩写，它来自一句谚语：“pull oneself up by one’s bootstraps”字面意思是”拽着鞋带把自己拉起来”，这当然是不可能的事情。最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！</p>
<p>早期真的是这样，必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。所以，工程师们把这个过程叫做”拉鞋带”，久而久之就简称为boot了。</p>
</blockquote>
<h3 id="1-第一阶段bios"><strong>1. 第一阶段：</strong><code>BIOS</code><a hidden class="anchor" aria-hidden="true" href="#1-第一阶段bios">#</a></h3>
<p>上个世纪70年代初，&ldquo;只读内存&rdquo;（<code>read-only memory</code>，缩写为<code>ROM</code>）发明，开机程序被刷入<code>ROM</code>芯片，计算机通电后，第一件事就是读取它。</p>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100962334-d9084f25-0440-4661-8bc9-db6101b04b5a-227847.jpeg" alt=""></p>
<p>这块芯片里的程序叫做&quot;基本输入输出系統&rdquo;（<code>Basic Input/Output System</code>），简称为<code>BIOS</code>。</p>
<p><strong>1.1  上电及硬件自检</strong></p>
<p>按下电脑上的电源按钮<strong>上电</strong>后, CPU的<code>RESET</code>引脚会产生一个逻辑值来复位CPU, <strong>CPU唤醒</strong>后, CPU将在<code>0xfffffff0</code>处执行一条<strong>长跳转指令</strong>, 直接跳到固化在ROM中的启动代码处(即<code>BIOS</code>), 将其加载到<code>RAM</code>，然后执行<code>BIOS</code>的代码.</p>
<blockquote>
<p>BIOS中主要存放的程序包括：</p>
<ul>
<li>自诊断程序（通过读取CMOS RAM中的内容识别硬件配置，并对其进行自检和初始化）</li>
<li>CMOS设置程序（引导过程中，通过特殊热键启动，进行设置后，存入CMOS RAM中）</li>
<li>系统自动装载程序（在系统自检成功后，将磁盘相对0道0扇区上的引导程序装入内存使其运行）</li>
<li>主要I/O驱动程序和中断服务（BIOS和硬件直接打交道，需要加载I/O驱动程序）</li>
</ul>
</blockquote>
<p>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做&quot;<strong>硬件自检</strong>&quot;（<code>Power-On Self-Test</code>），缩写为<code>POST</code>。</p>
<p>如果硬件出现问题，主板会发出不同含义的<strong>蜂鸣</strong>，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</p>
<p><strong>1.2 启动顺序</strong></p>
<p>硬件自检完成后，<code>BIOS</code>把控制权转交给<strong>下一阶段的启动程序</strong>。</p>
<p>这时，<code>BIOS</code>需要知道，&ldquo;下一阶段的启动程序&quot;具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做&quot;启动顺序&rdquo;（<code>Boot Sequence</code>）。</p>
<p>打开BIOS的操作界面，里面有一项就是&quot;设定启动顺序&quot;。</p>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100962362-a26859f6-4142-44f3-b407-e30de3457058-316879.jpeg" alt="bg2013021504.jpg"></p>
<h3 id="2-第二阶段主引导记录"><strong>2. 第二阶段：主引导记录</strong><a hidden class="anchor" aria-hidden="true" href="#2-第二阶段主引导记录">#</a></h3>
<p><code>BIOS</code>按照&quot;启动顺序&quot;，<strong>把控制权转交给排在第一位的储存设备</strong>。<strong>即根据用户指定的引导顺序从软盘、硬盘或是可移动设备中读取启动设备的</strong><code>MBR</code>，<strong>并放入指定的位置（</strong><code>0x7c000</code><strong>）内存中。</strong>(<code>BIOS</code>的最后一个任务)</p>
<p>这时，计算机<strong>读取该设备的第一个扇区</strong>，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是<code>0x55</code>和<code>0xAA</code>(用来标识该磁盘是否为<strong>引导磁盘)</strong>，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给&quot;启动顺序&quot;中的下一个设备。</p>
<blockquote>
<p>为什么是0x55和0xaa? 因为aa展开为10101010, 55展开为01010101,变成串行电平的话就是一个占空比为50%的方波， 这种方波在电路中最容易被分辨是否受干扰或者畸变.</p>
</blockquote>
<p>这最前面的512个字节，就叫做**&ldquo;主引导记录&rdquo;**（<code>Master boot record</code>，缩写为<code>MBR</code>）。</p>
<p><strong>2.1 主引导记录</strong><code>MBR</code><strong>的结构</strong></p>
<p>&ldquo;主引导记录&quot;只有512个字节，放不了太多东西。<strong>它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统</strong>。</p>
<p>主引导记录由三个部分组成：</p>
<pre tabindex="0"><code>（1） 第1-446字节：调用操作系统的机器码。
（2） 第447-510字节：分区表（Partition table）。
（3） 第511-512字节：主引导记录签名（0x55和0xAA）。
</code></pre><p>其中，第二部分&rdquo;<strong>分区表</strong>&ldquo;的作用，是将硬盘分成若干个区。</p>
<p><strong>2.2 分区表</strong></p>
<p>硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，&ldquo;主引导记录&quot;因此必须知道将控制权转交给哪个区。</p>
<p>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做&quot;主分区&rdquo;。</p>
<p>每个主分区的16个字节，由6个部分组成：</p>
<blockquote>
<p>（1）第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
（2）第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。
（3）第5个字节：主分区类型。
（4）第6-8个字节：主分区最后一个扇区的物理位置。
（5）第9-12字节：该主分区第一个扇区的逻辑地址。
（6）第13-16字节：主分区的扇区总数。</p>
</blockquote>
<p>最后的四个字节（&ldquo;主分区的扇区总数&rdquo;），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。</p>
<p>如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。</p>
<h3 id="3-第三阶段硬盘启动"><strong>3. 第三阶段:硬盘启动</strong><a hidden class="anchor" aria-hidden="true" href="#3-第三阶段硬盘启动">#</a></h3>
<p>这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。</p>
<p><strong>3.1 情况A：要引导的操作系统位于主分区</strong>(后两种不要求掌握)</p>
<p>上一节提到，四个主分区里面，<strong>只有一个是激活的</strong>。计算机会读取**激活分区(活动分区)**的第一个扇区，叫做&rdquo;<strong>卷引导记录</strong>&quot;（<code>Volume boot record</code>，缩写为<code>VBR</code>）。</p>
<blockquote>
<p>王道书里把这个扇区称为&quot;分区引导记录PBR&quot;</p>
</blockquote>
<hr>
<p><strong>3.2 情况B：位于扩展分区和逻辑分区</strong></p>
<p>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成&quot;扩展分区&quot;（<code>Extended partition</code>）。</p>
<p>所谓&quot;扩展分区&quot;，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做&quot;逻辑分区&quot;（<code>logical partition</code>）。</p>
<p>计算机先读取扩展分区的第一个扇区，叫做&quot;<strong>扩展引导记录</strong>&quot;（<code>Extended boot record</code>，缩写为<code>EBR</code>）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。</p>
<p>计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，<strong>扩展分区可以包含无数个逻辑分区。</strong></p>
<p>但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。</p>
<p><strong>3.3 情况C：启动管理器</strong></p>
<p>在这种情况下，计算机读取&quot;主引导记录&quot;前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的&quot;<strong>启动管理器</strong>&quot;（<code>boot loader</code>），由用户选择启动哪一个操作系统。</p>
<p>Linux环境中，目前最流行的启动管理器是<code>Grub</code>。</p>
<h3 id="4-第四阶段操作系统"><strong>4. 第四阶段：操作系统</strong><a hidden class="anchor" aria-hidden="true" href="#4-第四阶段操作系统">#</a></h3>
<p><strong>分区引导记录</strong><code>PBR</code><strong>找到引导操作系统的程序后，</strong> 控制权转交给操作系统，操作系统的内核首先被载入内存。</p>
<p>以<code>Linux</code>系统为例，先载入<code>/boot</code>目录下面的<code>kernel</code>。内核加载成功后，第一个运行的程序是<code>/sbin/init</code>。它根据配置文件（Debian系统是/etc/initab）产生<code>init</code>进程。这是Linux启动后的第一个进程，<code>pid</code>进程编号为1，其他进程都是它的后代。</p>
<p>然后，<code>init</code>线程加载系统的各个模块，比如窗口程序和网络程序，直至执行<code>/bin/login</code>程序，跳出登录界面，等待用户输入用户名和密码。</p>
<p><strong>至此，全部启动过程完成。</strong></p>
<blockquote>
<p>计算机开机时，操作系统所处的位置是（D）</p>
<p>A、内存 ROM</p>
<p>B、内存 RAM</p>
<p>C、磁盘主引导扇区</p>
<p>D、以上都不对</p>
<p>解析:计算机开机后，<strong>先执行 ROM 中的引导程序，将主引导扇区 MBR 中的程序放入内存中执行，再通过该程序去将操作系统程序装入内存中并移交 cpu 控制权给操作系统</strong>，因此答案选 D</p>
</blockquote>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1745416888259-85ecb34f-196b-449d-8b2c-1113988bf346-077351.png" alt="磁盘管理&#43;安装OS&#43;OS引导&#43;OS初始化"></p>
<p>磁盘管理+安装OS+OS引导+OS初始化</p>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1745247149639-8ac29e50-7238-44d6-a364-699ab4ab8527-294096.webp" alt="单独的操作系统引导示意图"></p>
<p><strong>单独的操作系统引导示意图</strong></p>
<blockquote>
<p>【小贴士】：实地址模式（Real Mode)是Intel为80286及其之后的处理器提供的一种8086兼容模式。采用20位存储器地址空间，即可寻址空间为1MB，不支持分页存储管理机制。每个存储单元地址由16位段地址左移4位后与16位偏移量相加而得到。</p>
<ul>
<li><strong>开机后系统首先在实地址模式下工作</strong></li>
<li>因此，开机过程中，需要先准备在实地址模式下的<strong>中断向量表和中断服务程序</strong>。通常，这个准备工作是由固化在计算机主板上的一块ROM芯片中的<code>BIOS</code>程序来完成的。</li>
<li>BIOS程序首先检测显卡、键盘、内存等，并在主存的<code>00000H~003FFH</code>区域建立<strong>中断向量表</strong>，同时，在中断向量所指的主存区域建立相应的<strong>中断服务程序</strong></li>
<li>BIOS<strong>利用</strong><code>INT</code><strong>指令执行特定的中断服务程序</strong>可以把操作系统内核程序从磁盘加载到内存中。例如，<code>BIOS</code>可以通过执行指令<code>int0x19</code>来调用中断向量<code>0x19</code>对应的中断服务程序，<strong>将启动盘上的0号磁头对应盘面的0磁道1扇区中的引导程序装入内存</strong>。</li>
<li><code>BIOS(Basic Input/Output System）</code>是基本输入/输出系统的简称，是针对具体的主板设计的，与安装的操作系统无关。</li>
<li>BIOS中包含了各种基本设备的驱动程序，通过执行BIOS程序，这些基本设备驱动程序以中断服务程序的形式被加载到内存中，以提供基本I/O系统调用。<strong>一旦进入保护模式，就不再使用BIOS。</strong></li>
</ul>
<p>摘自袁春风《计算机系统基础》</p>
</blockquote>
<hr>
<h2 id="16-虚拟机">1.6 虚拟机<a hidden class="anchor" aria-hidden="true" href="#16-虚拟机">#</a></h2>
<p>虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器（<code>Virtual Machine, VM</code>），每个虚拟机器都可以独立运行一个操作系统</p>
<p>同义术语：虚拟机管理程序/虚拟机监控程序/<code>Virtual Machine Monitor</code>/<code>Hypervisor</code></p>
<blockquote>
<p>提供虚拟机管理程序并不属于操作系统的任务，第二类虚拟机管理程序是一种应用程序。</p>
</blockquote>
<h3 id="161-第一类虚拟机管理程序裸金属架构">1.6.1 第一类虚拟机管理程序(裸金属架构)<a hidden class="anchor" aria-hidden="true" href="#161-第一类虚拟机管理程序裸金属架构">#</a></h3>
<p>从技术上讲，第一类虚拟机管理程序就像一个操作系统，因为它是唯一一个运行在最高特权级的程序。它在裸机上运行并且具备多道程序功能。虚拟机管理程序向上层提供若干台虚拟机，这些虚拟机是裸机硬件的精确复制品。由于每台虚拟机都与裸机相同，所以在不同的虚拟机上可以运行任何不同的操作系统。图中显示了第一类虚拟机管理程序。</p>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100962410-04d9a55f-e20b-405f-99d1-f0b5283bf195-064179.png" alt=""></p>
<ul>
<li>虚拟机作为用户态的一个进程运行，不允许执行敏感指令。然而，虚拟机上的操作系统认为自己运行在内核态（实际上不是），称为虚拟内核态。虚拟机中的用户进程认为自己运行在用户态（实际上确实是)。当虚拟机操作系统执行了一条CPU处于内核态才允许执行的指令时，会陷入虚拟机管理程序。在支持虚拟化的CPU上，虚拟机管理程序检查这条指令是由虚拟机中的操作系统执行的还是由用户程序执行的。如果是前者，虚拟机管理程序将安排这条指令功能的正确执行。否则，虚拟机管理程序将模拟真实硬件面对用户态执行敏感指令时的行为。</li>
</ul>
<p>在过去不支持虚拟化的CPU上，真实硬件不会直接执行虚拟机中的敏感指令，这些敏感指令被转为对虚拟机管理程序的调用，由虚拟机管理程序模拟这些指令的功能。</p>
<ul>
<li>第一类虚拟机执行一条特权指令的过程
<ol>
<li><strong>指令执行尝试</strong>：在虚拟机内部，操作系统（虚拟操作系统）尝试执行一条特权指令。由于虚拟操作系统运行在虚拟内核态，它认为自己有权执行此类指令。</li>
<li><strong>指令截获</strong>：虚拟机中执行的特权指令被虚拟机管理程序（hypervisor）截获。在具备硬件虚拟化支持的现代CPU中，这通常通过硬件辅助的特性（如Intel的VT-x或AMD的AMD-V）实现。这些技术使得CPU能够在尝试执行特权指令时，自动将控制权转交给虚拟机管理程序。</li>
<li><strong>检查与执行</strong>：虚拟机管理程序接收到控制权后，首先确定指令的来源是虚拟操作系统还是虚拟机内的一个用户程序。如果确认是虚拟操作系统发出的特权指令，虚拟机管理程序将按照指令的要求，利用它对硬件的直接控制能力，来安全地执行该指令。</li>
<li><strong>模拟行为</strong>：如果该特权指令是由用户程序错误地尝试执行的，则虚拟机管理程序会模拟硬件对非法特权指令执行的响应，通常是通过抛出异常或错误处理。</li>
<li><strong>返回控制权</strong>：指令执行完毕后，虚拟机管理程序将控制权返回给虚拟机，使得虚拟机操作系统或应用程序可以继续运行。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="162-第二类虚拟机管理程序寄居架构">1.6.2 第二类虚拟机管理程序(寄居架构)<a hidden class="anchor" aria-hidden="true" href="#162-第二类虚拟机管理程序寄居架构">#</a></h3>
<p>
  <img src="https://cos.izumichan16.cn/408note/OS/F3KQyYi3WGr-a6Ks/1734100962414-d4ed9e5e-41e6-4f4e-9d1c-c1f359e53074-619379.png" alt=""></p>
<p>图中显示了第二类虚拟机管理程序。**它是一个依赖于Windows、Linux等操作系统分配和调度资源的程序，很像一个普通的进程。**第二类虚拟机管理程序仍然伪装成具有CPU和各种设备的完整计算机。<code>VMware Workstation</code> 是首个X86平台上的第二类虚拟机管理程序。</p>
<p>运行在第二类虚拟机管理程序上的操作系统都称为<strong>客户操作系统</strong>。对于第二类虚拟机管理程序，运行在底层硬件上的操作系统称为<strong>宿主操作系统</strong>。</p>
<p>第二类虚拟机管理程序负责将虚拟机程序的虚拟地址转换为宿主操作系统中的虚拟地址（该虚拟地址在虚拟机 OS 看来是&quot;物理地址&quot;），再由宿主操作系统转换为真正的物理地址。</p>
<p>首次启动时，第二类虚拟机管理程序像一台刚启动的计算机那样运转，期望找到的驱动器可以是虚拟设备。然后将操作系统安装到虚拟磁盘上（其实只是宿主操作系统中的一个文件）。客户操作系统安装完成后，就能启动并运行。</p>
<p>虚拟化在Web主机领域很流行。<strong>没有虚拟化，服务商只能提供共享托管（不能控制服务器的软件）<strong>和</strong>独占托管</strong>（成本较高）。当服务商提供租用虚拟机时，一台物理服务器就可以运行多个虚拟机，每个虚拟机看起来都是一台完整的服务器，客户可以在虚拟机上安装自己想用的操作系统和软件，但是只需支付较低的费用。这就是市面上常见的“云”主机。</p>
<table>
  <thead>
      <tr>
          <th>对比项</th>
          <th>第一类 VMM</th>
          <th>第二类 VMM</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>对物理资源的控制权</td>
          <td>直接运行在硬件之上，能直接控制和分配物理资源</td>
          <td>运行在Host OS之上，依赖 Host OS为其分配物理资源</td>
      </tr>
      <tr>
          <td>资源分配方式</td>
          <td>安装Guest OS时，VMM在硬盘上为其分配存储空间，类似&quot;外接&quot;方式，直接分配未经抽象的物理硬件</td>
          <td>GuestOS拥有自己的虚拟磁盘，该磁盘实际是Host OS文件系统中的一个文件；GuestOS分配到的内存是虚拟内存</td>
      </tr>
      <tr>
          <td>性能</td>
          <td>性能更好</td>
          <td>性能更差，需要Host OS作为&quot;中介&quot;</td>
      </tr>
      <tr>
          <td>可支持的虚拟机数量</td>
          <td>更多；不需要和Host OS竞争资源，相同硬件资源可支持更多虚拟机</td>
          <td>更少；Host OS本身要使用物理资源，Host OS上运行的其他进程也需要物理资源</td>
      </tr>
      <tr>
          <td>虚拟机的可迁移性</td>
          <td>更差</td>
          <td>更好；只需导出虚拟机镜像文件即可迁移到另一台HostOS上，商业化应用更广</td>
      </tr>
      <tr>
          <td>运行模式</td>
          <td>运行在最高特权级（Ring 0），可执行最高特权指令</td>
          <td>部分运行在用户态，部分运行在内核态；GuestOS发出的系统调用会被VMM截获，转化为对HostOS的系统调用</td>
      </tr>
  </tbody>
</table>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://twojian.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://twojian.github.io/posts/tutorials/n8n/n8n-maintenance-guide/">
    <span class="title">« Prev</span>
    <br>
    <span>n8n 维护运维手册（Docker Compose 方案）</span>
  </a>
  <a class="next" href="https://twojian.github.io/posts/tutorials/latex%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-/">
    <span class="title">Next »</span>
    <br>
    <span>Latex基本语法</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 408|操作系统笔记：第一章 操作系统概述 on x"
            href="https://x.com/intent/tweet/?text=408%7c%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%ac%94%e8%ae%b0%ef%bc%9a%e7%ac%ac%e4%b8%80%e7%ab%a0%20%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%a6%82%e8%bf%b0&amp;url=https%3a%2f%2ftwojian.github.io%2fposts%2fblog%2f%25E7%25AC%25AC%25E4%25B8%2580%25E7%25AB%25A0%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E6%25A6%2582%25E8%25BF%25B0%2f&amp;hashtags=%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%2c">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 408|操作系统笔记：第一章 操作系统概述 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ftwojian.github.io%2fposts%2fblog%2f%25E7%25AC%25AC%25E4%25B8%2580%25E7%25AB%25A0%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E6%25A6%2582%25E8%25BF%25B0%2f&amp;title=408%7c%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%ac%94%e8%ae%b0%ef%bc%9a%e7%ac%ac%e4%b8%80%e7%ab%a0%20%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%a6%82%e8%bf%b0&amp;summary=408%7c%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%ac%94%e8%ae%b0%ef%bc%9a%e7%ac%ac%e4%b8%80%e7%ab%a0%20%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%a6%82%e8%bf%b0&amp;source=https%3a%2f%2ftwojian.github.io%2fposts%2fblog%2f%25E7%25AC%25AC%25E4%25B8%2580%25E7%25AB%25A0%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E6%25A6%2582%25E8%25BF%25B0%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 408|操作系统笔记：第一章 操作系统概述 on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2ftwojian.github.io%2fposts%2fblog%2f%25E7%25AC%25AC%25E4%25B8%2580%25E7%25AB%25A0%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E6%25A6%2582%25E8%25BF%25B0%2f&title=408%7c%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%ac%94%e8%ae%b0%ef%bc%9a%e7%ac%ac%e4%b8%80%e7%ab%a0%20%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%a6%82%e8%bf%b0">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 408|操作系统笔记：第一章 操作系统概述 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftwojian.github.io%2fposts%2fblog%2f%25E7%25AC%25AC%25E4%25B8%2580%25E7%25AB%25A0%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E6%25A6%2582%25E8%25BF%25B0%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 408|操作系统笔记：第一章 操作系统概述 on whatsapp"
            href="https://api.whatsapp.com/send?text=408%7c%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%ac%94%e8%ae%b0%ef%bc%9a%e7%ac%ac%e4%b8%80%e7%ab%a0%20%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%a6%82%e8%bf%b0%20-%20https%3a%2f%2ftwojian.github.io%2fposts%2fblog%2f%25E7%25AC%25AC%25E4%25B8%2580%25E7%25AB%25A0%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E6%25A6%2582%25E8%25BF%25B0%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 408|操作系统笔记：第一章 操作系统概述 on telegram"
            href="https://telegram.me/share/url?text=408%7c%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%ac%94%e8%ae%b0%ef%bc%9a%e7%ac%ac%e4%b8%80%e7%ab%a0%20%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%a6%82%e8%bf%b0&amp;url=https%3a%2f%2ftwojian.github.io%2fposts%2fblog%2f%25E7%25AC%25AC%25E4%25B8%2580%25E7%25AB%25A0%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E6%25A6%2582%25E8%25BF%25B0%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 408|操作系统笔记：第一章 操作系统概述 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=408%7c%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%ac%94%e8%ae%b0%ef%bc%9a%e7%ac%ac%e4%b8%80%e7%ab%a0%20%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%a6%82%e8%bf%b0&u=https%3a%2f%2ftwojian.github.io%2fposts%2fblog%2f%25E7%25AC%25AC%25E4%25B8%2580%25E7%25AB%25A0%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E6%25A6%2582%25E8%25BF%25B0%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://twojian.github.io/">Twojian Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
